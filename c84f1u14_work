<?xml version="1.0"?>
<!DOCTYPE profile SYSTEM "/usr/share/YaST2/include/autoinstall/profile.dtd">
<profile xmlns="http://www.suse.com/1.0/yast2ns" xmlns:config="http://www.suse.com/1.0/configns">
  <install>
    <bootloader>
      <write_bootloader config:type="boolean">true</write_bootloader>
      <activate config:type="boolean">true</activate>
      <kernel_parameters></kernel_parameters>
      <lba_support config:type="boolean">false</lba_support>
      <linear config:type="boolean">false</linear>
      <location>mbr</location>
    </bootloader>
    <general>
      <clock>
        <hwclock>UTC</hwclock>
        <timezone>America/New_York</timezone>
      </clock>
      <keyboard>
        <keymap>english-us</keymap>
      </keyboard>
      <language>en_US</language>
      <mode>
        <confirm config:type="boolean">false</confirm>
        <forceboot config:type="boolean">false</forceboot>
        <interactive_boot config:type="boolean">false</interactive_boot>
        <reboot config:type="boolean">true</reboot>
      </mode>
      <mouse>
        <id>non</id>
      </mouse>
      <signature-handling>
         <accept_non_trusted_gpg_key config:type="boolean">true</accept_non_trusted_gpg_key>
         <accept_unknown_gpg_key config:type="boolean">true</accept_unknown_gpg_key>
         <accept_unsigned_file config:type="boolean">true</accept_unsigned_file>
      </signature-handling>
    </general>
    <partitioning config:type="list">
      <!-- XCAT-PARTITION-START -->
      <drive>
        <device>XCATPARTITIONHOOK</device>
        <initialize config:type="boolean">true</initialize>
        <use>all</use>
      </drive>
      <!-- XCAT-PARTITION-END -->
    </partitioning>
    <add-on>
        <add_on_products config:type="list">
             
        </add_on_products>
    </add-on>
    <software>
      <products config:type="list">
          <product>SLES</product>
      </products>
      <patterns config:type="list">
        
      </patterns>
      <packages config:type="list">
    	<package>iputils</package>
<package>vim</package>
<package>openssl</package>
<package>rsync</package>
<package>insserv-compat</package>
<package>net-tools-deprecated</package>
<package>rsyslog</package>
<package>nfs-client</package>
      </packages>
    </software>
  </install>
  <configure>
    <users config:type="list">
      <user>
        <username>root</username>
        <user_password></user_password>
        <encrypted config:type="boolean">true</encrypted>
        <forename/>
        <surname/>
      </user>
    </users>
    <networking>
      <dns>
        <dhcp_hostname config:type="boolean">true</dhcp_hostname>
        <dhcp_resolv config:type="boolean">true</dhcp_resolv>
        <domain>local</domain>
        <hostname>linux</hostname>
      </dns>
      <interfaces config:type="list">
        <interface>
          <bootproto>dhcp</bootproto>
          <device>eth0</device>
          <startmode>onboot</startmode>
        </interface>
      </interfaces>
      <routing>
        <ip_forward config:type="boolean">false</ip_forward>
        <routes config:type="list"/>
      </routing>
    </networking>
    <scripts>
         <pre-scripts config:type="list">
        <script>
          <filename>foo.sh</filename>
          <interpreter>shell</interpreter>
          <debug config:type="boolean">false</debug>
          <source>

<![CDATA[
#!/bin/sh

{
export MASTER_IP="10.28.0.30"
declare -F msgutil_r &>/dev/null  || function msgutil_r {
   local logserver=$1
   local msgtype=$2
   local msgstr=$3
   local logfile=$4
   local logtag=$5

   if [ -z "$msgtype"  ]; then
      msgtype="debug"
   fi

   if [ -z "$logtag" ]; then
      logtag="xcat"
   fi

   if [ -n "$logserver" ];then
      logger -n $logserver -t $logtag -p local4.$msgtype "$msgstr"
      if [ "$?" != "0" ];then
         exec 3<>/dev/udp/$logserver/514 >/dev/null;logger -s -t $logtag -p local4.$msgtype "$msgstr" 2>&3
         if [ "$?" != "0" ];then
            logger -s -t $logtag -p local4.$msgtype "$msgstr" 2>&1|nc $logserver 514 >/dev/null 2>&1
            if [ "$?" != "0" ];then
               logger -t $logtag -p local4.$msgtype "$msgstr"
            fi
         fi
      fi
   else
       logger -t $logtag -p local4.$msgtype "$msgstr"
   fi
   if [ -n "$logfile"  ]; then
      local logdir="$(dirname $logfile)"
      if [ ! -d "$logdir" ]; then
         mkdir -p "$logdir"
         touch "$logfile"
      fi

      echo "$(date) [$msgtype]: $logtag: $msgstr" >> $logfile
   fi

}

declare -F msgutil &>/dev/null  || function msgutil {
    msgutil_r "" "$@"
}

log_label="xcat.deployment"
msgutil_r "$MASTER_IP" "info" "============deployment starting============" "/var/log/xcat/xcat.log" "$log_label"
msgutil_r "$MASTER_IP" "info" "Running AutoYaST Pre-Installation script..." "/var/log/xcat/xcat.log" "$log_label"
echo "Running AutoYaST Pre-Installation script..."

export XCATDEBUGMODE=""
if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
    set -x
fi

AWK=`find / -name awk | tail -1`
#old awk /mounts/instsys/bin/awk -f
if [ ! -e /usr/bin/awk ]; then
    ln -s $AWK /usr/bin/awk
fi

XCATDPORT=3002
XCATDHOST="10.28.0.30"

(
cat << 'EOF'
#!/usr/bin/awk -f
# IBM(c) 2007 EPL license http://www.eclipse.org/legal/epl-v10.html

BEGIN {
    xcatdhost = ARGV[1]
    xcatdport = ARGV[2]
    flag = ARGV[3]

    if (!flag) flag = "next"

    ns = "/inet/tcp/0/" xcatdhost "/" xcatdport

    loop = 0
    while(1) {
        if((ns |& getline) > 0)
            print $0 | "logger -t xcat -p local4.info"
        else {
            print "Retrying flag update" | "logger -t xcat -p local4.info"
            print "updateflag.awk: Retrying flag update" >> "/var/log/xcat/xcat.log"
            close(ns)
            system("sleep 10")
            loop = loop + 1
        }

        if($0 == "ready")
            print flag |& ns
        if($0 == "done")
            break
        if(loop > 10) {
            print "flag update failed" | "logger -t xcat -p local4.info"
            print "updateflag.awk: flag update failed" >> "/var/log/xcat/xcat.log"
            break
        }
    }

    close(ns)

    exit 0
}

EOF
) > /tmp/updateflag


if [ ! -c /dev/vcs ]; then
	mknod /dev/vcs c 7 0
fi
cat >/tmp/foo.awk <<EOF
#!$AWK -f

BEGIN {
	ns = "/inet/tcp/3054/0/0"

	while(1) {
		ns |& getline

#UNCOMMENTOENABLEDEBUGPORT#		if(\$1 == "sh") { #TODO: ENABLE IF DEBUG
#UNCOMMENTOENABLEDEBUGPORT#			sub(/^sh +/,"",\$0)
#UNCOMMENTOENABLEDEBUGPORT#			output = \$0
#UNCOMMENTOENABLEDEBUGPORT#			while((output | getline) > 0)
#UNCOMMENTOENABLEDEBUGPORT#				print \$0 |& ns
#UNCOMMENTOENABLEDEBUGPORT#			print "EOO" |& ns
#UNCOMMENTOENABLEDEBUGPORT#			close(output)
#UNCOMMENTOENABLEDEBUGPORT#		}

		if(\$1 == "screendump") {
			output = "chvt " \$2 ";cat /dev/vcs"
			while((output | getline) > 0)
				print \$0 |& ns
			close(output)
		}

		if(\$1 == "stat") {
		    if( system( "[ -f /mnt/var/log/YaST2/y2logRPM ]" )  == 0 ) {
			while((getline < "/mnt/var/log/YaST2/y2logRPM") > 0) {
				line = \$0
			}
			close("/mnt/var/log/YaST2/y2logRPM")

			if(line ~ /\.rpm /) {
				sub(/\.[^\.]+\.rpm .*$/,"",line)
				sub(/^.* /,"",line)
			}
			else {
				line = "prep"
			}

			print ("installing " line) |& ns
		    }
         	    else {
			# The format of /var/log/zypp/history is documented at
			#     http://en.opensuse.org/Libzypp/Package_History

			lastrpm = "prep"

			oldFS = FS
			FS="|"

			while((getline < "/mnt/var/log/zypp/history") > 0) {
				if (\$0 !~ /#/ && \$2 == "install") {
					lastrpm = (\$3 "-" \$4)
				}
			}
			close("/mnt/var/log/zypp/history")

			FS = oldFS

			print ("installing " lastrpm) |& ns
                   }
               }

	       close(ns)
	}
}
EOF

chmod 755 /tmp/foo.awk
chmod 755 /tmp/updateflag

/tmp/updateflag $XCATDHOST $XCATDPORT "installmonitor" &

NODESTATUS=

if [ -z "$NODESTATUS" ] || [ "$NODESTATUS" != "0" -a   "$NODESTATUS" != "N"  -a  "$NODESTATUS" != "n" ]; then
   /tmp/updateflag $XCATDHOST $XCATDPORT "installstatus installing" &
fi

/tmp/foo.awk >/tmp/foo.log 2>&1 &

base64decode()
{
    h0="0";  h1="1";  h2="2";  h3="3";  h4="4";  h5="5";  h6="6";  h7="7";
    h8="8";  h9="9"; h10="A"; h11="B"; h12="C"; h13="D"; h14="E"; h15="F";

    while :
    do
        i=0
        while [ "$i" -lt 4 ]
        do
            read -n 1 c || return

            case "${c}" in
            "A") d=0  ;; "B") d=1  ;; "C") d=2  ;; "D") d=3  ;;
            "E") d=4  ;; "F") d=5  ;; "G") d=6  ;; "H") d=7  ;;
            "I") d=8  ;; "J") d=9  ;; "K") d=10 ;; "L") d=11 ;;
            "M") d=12 ;; "N") d=13 ;; "O") d=14 ;; "P") d=15 ;;
            "Q") d=16 ;; "R") d=17 ;; "S") d=18 ;; "T") d=19 ;;
            "U") d=20 ;; "V") d=21 ;; "W") d=22 ;; "X") d=23 ;;
            "Y") d=24 ;; "Z") d=25 ;; "a") d=26 ;; "b") d=27 ;;
            "c") d=28 ;; "d") d=29 ;; "e") d=30 ;; "f") d=31 ;;
            "g") d=32 ;; "h") d=33 ;; "i") d=34 ;; "j") d=35 ;;
            "k") d=36 ;; "l") d=37 ;; "m") d=38 ;; "n") d=39 ;;
            "o") d=40 ;; "p") d=41 ;; "q") d=42 ;; "r") d=43 ;;
            "s") d=44 ;; "t") d=45 ;; "u") d=46 ;; "v") d=47 ;;
            "w") d=48 ;; "x") d=49 ;; "y") d=50 ;; "z") d=51 ;;
            "0") d=52 ;; "1") d=53 ;; "2") d=54 ;; "3") d=55 ;;
            "4") d=56 ;; "5") d=57 ;; "6") d=58 ;; "7") d=59 ;;
            "8") d=60 ;; "9") d=61 ;; "+") d=62 ;; "/") d=63 ;;
            "=") d=0  ;;
            *) continue ;;
            esac

            eval "a${i}=${c}"
            eval "b${i}=${d}"

            i=$(( i + 1 ))
        done

        o0=$(( ((b0 << 2) | (b1 >> 4)) & 0xff ))
        o1=$(( ((b1 << 4) | (b2 >> 2)) & 0xff ))
        o2=$(( ((b2 << 6) | b3) & 0xff ))

        [ "${a2}" == "=" ] &&
            eval "printf \"\\x\${h$(( o0 / 16 ))}\${h$(( o0 % 16
                ))}\"" &&
            return
        [ "${a3}" == "=" ] &&
            eval "printf \"\\x\${h$(( o0 / 16 ))}\${h$(( o0 % 16
                ))}\\x\${h$(( o1 / 16 ))}\${h$(( o1 % 16
                ))}\"" &&
            return
        eval "printf \"\\x\${h$(( o0 / 16 ))}\${h$(( o0 % 16
            ))}\\x\${h$(( o1 / 16 ))}\${h$(( o1 % 16
            ))}\\x\${h$(( o2 / 16 ))}\${h$(( o2 % 16 ))}\""
    done
}

shopt -s nullglob
msgutil_r "$MASTER_IP" "info" "Detecting install disk..." "/var/log/xcat/xcat.log" "$log_label"
#
# The getinstdisk script is common for RHEL/SLES/PowerKVM/Ubuntu. 
# It will attempt to select the install disk and write the selection to /tmp/xcat.install_disk
#
#!/bin/sh

#-----------------------------------------------------------
#
# Get proper disk to install OS
#
# 1. Check all partitions list in /proc/partitions, whether
#    there is disk had OS installed. If there is, add it to
#    the disk array.
# 2. If there is disk had OS installed, check disks list
#    generated in Step 1. Else, check all disks get from
#    /proc/partitions file. Sort them by WWN/PATH and driver
#    type, select the first one.
# 3. Select the default one: /dev/sda.
#
# Output: /tmp/xcat.install_disk
#
#-----------------------------------------------------------

install_disk=""
install_disk_file="/tmp/xcat.install_disk"

tmpdir="/tmp/xcat.getinstalldisk"
mkdir -p $tmpdir

has_awk=$(find /usr/* -name "awk")

utolcmd="sed -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/"

tmpfile="$tmpdir/getinstalldisk_"

if [ -z "$install_disk" ]; then

    echo "[get_install_disk]Information from /proc/partitions:"
    cat /proc/partitions
    echo ""

    # Get all partitions and disks from /proc/partitions file
    if [ -z "$has_awk" ]; then
        entries=$(cat /proc/partitions | sed 's/  */ /g' | cut -d " " -f5 | grep -v "name" | grep -E '^[s|h|v]d|nvme')
    else
        entries=$(awk -F ' '  '{print $4}' /proc/partitions | grep -v "name" | grep -E '^[s|h|v]d|nvme')
    fi

    # Classify entries by DEVTYPE
    for entry in $entries; do
        DEVSIZE=$(udevadm info --attribute-walk --name=$entry|grep size| sed -e 's/[^"]*"//' -e 's/"//'|tail -n 1)
        if [ -z "$DEVSIZE" -o $DEVSIZE -lt 262144 ]; then
            # ignore small devices, that are likely remote media or similar
            continue
        fi

        if [ -z "$has_awk" ]; then
            dev_type=$(udevadm info --query=property --name=/dev/$entry | grep -i "DEVTYPE" | cut -d "=" -f2 | $utolcmd)
        else
            dev_type=$(udevadm info --query=property --name=/dev/$entry | grep -i "DEVTYPE" | awk -F = '{print $2}' | $utolcmd)
        fi

        if [ "$dev_type" == "disk" ]; then
            disks=$disks"$entry "
        elif [ "$dev_type" == "partition" ]; then
            partitions=$partitions"$entry "
        fi
    done

    mount_dir=$tmpdir"/xcat.getinstalldisk.mount"
    mkdir -p $mount_dir;

    disk_array=""

    for partition in $partitions; do
        echo "[get_install_disk]Check the partition $partition."

        if [ -e "$tmpfile${partition%%[0-9]*}" ]; then
            echo "[get_install_disk]    The disk ${partition%%[0-9]*} had OS installed, check next partition."
            continue
        fi

        # Get partition's fs_type
        if [ -z "$has_awk" ]; then
            fs_type=$(udevadm info --query=property --name=/dev/$partition | grep -i "FS_TYPE" | cut -d "=" -f2)
        else
            fs_type=$(udevadm info --query=property --name=/dev/$partition | grep -i "FS_TYPE" | awk -F = '{print $2}')
        fi

        rc=255

        # Mount partition based on fs type, if fs_type is "swap", do not mount it, jump to next partition.
        if [ -z "$fs_type" ]; then
            mount /dev/$partition $mount_dir
            rc=$?
        elif [ "$fs_type" != "swap" ]; then
            mount -t $fs_type /dev/$partition $mount_dir
            rc=$?
        fi

        # Check whether mount successfully
        if [ $rc -eq 0 ]; then
            echo "[get_install_disk]    Partition $partition mount success."

            ker_dir=$mount_dir
            if [ -d "$mount_dir/boot" ]; then
                ker_dir="$mount_dir/boot"
            fi

            # If there is kernel file, add partition's disk into disk_array
            # It seems the kernel file in ubuntu and sles are named like vmlinux, but in RH it is called vmlinuz
            # To check both vmlinux and vmlinuz, use regular expression "vmlinu*" to match them
            for i in $ker_dir/vmlinu*; do
                disk_part=${partition%%[0-9]*}
                touch "$tmpfile$disk_part"
                disk_array=$disk_array"$disk_part "
                echo "[get_install_disk]    The partition $partition has kernel file."
                break
            done

            umount -l $mount_dir || echo "[get_install_disk]    $partition umount failed."
        else
            echo "[get_install_disk]    Partition $partition mount failed or the partition is swap."
        fi
    done

    # If disk_array is not empty, make disks equal disk_array for next step to sort
    if [ "$disk_array" ]; then
        disks=$disk_array
        echo "[get_install_disk]The disks which have kernel:"
        echo "[get_install_disk]    $disks"
        echo ""
    fi

    rmdir $mount_dir;

    for file in $tmpfile*; do
        rm $file;
    done

    has_wwn=0
    has_path=0
    file_pre=""
    disk_data=""

    # Check disks which had installed OS, or check all disks in /proc/partitions
    for disk in $disks; do
        # Get disk's information: WWN, PATH and DRIVER
        disk_info=$(udevadm info --query=property --name=$disk)
        output_for_wwn=$(IFS= ;echo $disk_info | grep '\<ID_WWN\>' | cut -d "=" -f2)
        disk_wwn=$(echo $output_for_wwn | $utolcmd)
        output_for_path=$(IFS= ;echo $disk_info | grep DEVPATH | cut -d "=" -f2)
        disk_path=$(echo $output_for_path | $utolcmd)
        disk_driver=$(udevadm info --attribute-walk --name=$disk | grep DRIVERS| grep -v '""'| grep -v '"sd"'|
                    \head -n 1| sed -e 's/[^"]*"//' -e 's/"//' | $utolcmd)

        echo "[get_install_disk]The disk $disk information: "
        echo "[get_install_disk]    disk_wwn=$disk_wwn"
        echo "[get_install_disk]    disk_path=$disk_path"
        echo "[get_install_disk]    disk_driver=$disk_driver"

        # Check whether there is WWN, PATH information
        if [ "$disk_wwn" ]; then
            has_wwn=1
            file_pre="wwn"
            disk_data=$disk_wwn
        elif [ $has_wwn -eq 1 ]; then
            echo "[get_install_disk]    The disk $disk has no wwn info."
            echo "[get_install_disk]    There is other disk has wwn info, so don't record this disk."
            continue;
        elif [ "$disk_path" ]; then
            has_path=1
            file_pre="path"
            disk_data=$disk_path
        elif [ $has_path -eq 1 ]; then
            echo "[get_install_disk]    The disk $disk has no wwn or path info."
            echo "[get_install_disk]    There is other disk has path info, so don't record this disk."
            continue;
        else
           file_pre="other"
           disk_data=""
        fi

        # Sort disks by DRIVER type
        case "$disk_driver" in
        "ata_piix"*|"PMC MaxRAID"|"ahci"|"megaraid_sas")
            echo "$disk $disk_data" >> "$tmpfile""$file_pre""firstchoicedisks"
            echo "[get_install_disk]    Add disk: $disk $disk_data into $file_pre firstchoicedisks"
            ;;
        "mptsas"|"mpt2sas"|"mpt3sas")
            echo "$disk $disk_data" >> "$tmpfile""$file_pre""secondchoicedisks"
            echo "[get_install_disk]    Add disk: $disk $disk_data into $file_pre secondchoicedisks"
            ;;
        *)
            echo "$disk $disk_data" >> "$tmpfile""$file_pre""thirdchoicedisks"
            echo "[get_install_disk]    Add disk: $disk $disk_data into $file_pre thirdchoicedisks"
            ;;
        esac
    done

    for seq in first second third; do
        if [ -s $tmpfile$file_pre${seq}choicedisks ]; then
            install_file="$tmpfile$file_pre${seq}choicedisks"
            break
        fi
    done

    if [ "$install_file" ] && [ -s $install_file ]; then
        install_disk=/dev/$(cat $install_file | grep -v "^$" | sort -k 2 -b | cut -d " " -f1 | head -n 1)
        echo "[get_install_disk]The install_disk is $install_disk by sorting $file_pre and DRIVER."
    fi

    for file in $tmpfile*; do
        rm $file;
    done
fi
rm -rf $tmpdir;

# Cannot find proper disk for OS install, select the default one "/dev/sda"
if [ -z "$install_disk" ]; then
    install_disk="/dev/sda"
    echo "[get_install_disk]The default install_disk is $install_disk."
fi

# Output the result to $install_disk_file
echo $install_disk > $install_disk_file
if [ -e "/tmp/xcat.install_disk" ]; then
    instdisk=`cat /tmp/xcat.install_disk`
fi

msgutil_r "$MASTER_IP" "info" "Found $instdisk, generate partition file..." "/var/log/xcat/xcat.log" "$log_label"
if [ -d /sys/firmware/efi ]; then
	sed -e 's!<device>XCATPARTITIONHOOK</device>!<device>'$instdisk'</device><partitions config:type="list"><partition><filesystem config:type="symbol">vfat</filesystem><mount>/boot/efi</mount><size>128mb</size></partition><partition><mount>swap</mount><size>auto</size></partition><partition><mount>/</mount><size>auto</size></partition></partitions>!' /tmp/profile/autoinst.xml > /tmp/profile/modified.xml
else
	sed -e 's!<device>XCATPARTITIONHOOK</device>!<device>'$instdisk'</device>!' /tmp/profile/autoinst.xml > /tmp/profile/modified.xml
fi
#XCA_PARTITION_SCRIPT#
#add the following part for replace the partition definition in /tmp/profile/autoinst.xml
if [ -r "/tmp/partitionfile" ]; then
    while read line
    do
        con="${con}${line}"
    done < /tmp/partitionfile
    con=${con//>\s+</><}
    con=${con// /xcattempspace}
    sed -e '/<drive>/{N;N;s!.*!'$con'!}' /tmp/profile/autoinst.xml > /tmp/profile/modified1.xml
    sed -e 's!xcattempspace! !g' /tmp/profile/modified1.xml > /tmp/profile/modified.xml
fi
msgutil_r "$MASTER_IP" "info" "Generate the repository for the installation" "/var/log/xcat/xcat.log" "$log_label"
export nextserver=`cat /proc/cmdline | grep http | awk -F'autoyast=http://' {'print \$2'} | awk -F':' {'print \$1'}`
cp /tmp/profile/modified.xml /tmp/profile/modified1.xml
sed -e 's!XCATNEXTSERVERHOOK!'$nextserver'!' /tmp/profile/modified1.xml > /tmp/profile/modified.xml



if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
    set +x
fi
} >>/tmp/pre-install.log 2>&1
]]>

          </source>
        </script>
      </pre-scripts>
         <chroot-scripts config:type="list">
        <script>
          <filename>boot.sh</filename>
          <interpreter>shell</interpreter>
          <debug config:type="boolean">false</debug>
          <source>

<![CDATA[
#!/bin/sh

mkdir -p /mnt/var/log/xcat/
{

cat /tmp/pre-install.log >> /mnt/var/log/xcat/xcat.log

echo "Running AutoYaST Chroot-Installation script..."

export XCATDEBUGMODE=""
if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
    set -x
fi

AWK=`find / -name awk | head -1`
#old awk /mounts/instsys/bin/awk -f
if [ ! -e /usr/bin/awk ]; then
    ln -s $AWK /usr/bin/awk
fi

XCATDPORT=3002
XCATDHOST="10.28.0.30"

(cat >/tmp/updateflag << 'EOF'
#!/usr/bin/awk -f
# IBM(c) 2007 EPL license http://www.eclipse.org/legal/epl-v10.html

BEGIN {
    xcatdhost = ARGV[1]
    xcatdport = ARGV[2]
    flag = ARGV[3]

    if (!flag) flag = "next"

    ns = "/inet/tcp/0/" xcatdhost "/" xcatdport

    loop = 0
    while(1) {
        if((ns |& getline) > 0)
            print $0 | "logger -t xcat -p local4.info"
        else {
            print "Retrying flag update" | "logger -t xcat -p local4.info"
            print "updateflag.awk: Retrying flag update" >> "/var/log/xcat/xcat.log"
            close(ns)
            system("sleep 10")
            loop = loop + 1
        }

        if($0 == "ready")
            print flag |& ns
        if($0 == "done")
            break
        if(loop > 10) {
            print "flag update failed" | "logger -t xcat -p local4.info"
            print "updateflag.awk: flag update failed" >> "/var/log/xcat/xcat.log"
            break
        }
    }

    close(ns)

    exit 0
}

EOF
) >/tmp/updateflag

chmod 755 /tmp/updateflag

/tmp/updateflag $XCATDHOST $XCATDPORT

export PRINIC=mac
if [ "$PRINIC" == "mac" ]
then
    export PRINIC='40:f2:e9:eb:4a:da'
fi
if [ -z "$PRINIC" ]
then
    for karg in $(cat /proc/cmdline |sed -e 's/-/:/g' -e 's/ /\n/g'); do
        if  [ "${karg%%=*}" = "BOOTIF" ]; then
            #export PRINIC=`ifconfig -a|grep -i "hwaddr ${karg#*=01:}"|awk '{print $1}'`
            export PRINIC=${karg#*=01:}
            export PRINIC=`ip -o link|grep -i "$PRINIC"|awk  '{print $2}'|sed s/://`
        fi
        if  [ "${karg%%=*}" = "netdevice" ]; then
            export PRINIC="${karg#*=}";
            if [ "${#PRINIC}" = "20" ]; then
               export PRINIC=${PRINIC:3:21}
            fi
        fi
    done
    if [ -z "$PRINIC" ]; then
        export PRINIC=eth0
    fi
fi
if [ -z "$PRINIC" ]
then
    export PRINIC=eth0
elif [[ `echo "$PRINIC" | grep -sqE ^[A-Fa-f0-9]+:[A-Fa-f0-9]+:[A-Fa-f0-9]+:[A-Fa-f0-9]+:[A-Fa-f0-9]+:[A-Fa-f0-9]+$ ;echo $?` == "0" ]]; then
    #export PRINIC=`ifconfig -a | grep -i "HWaddr $PRINIC" | awk '{print $1}'`
    export PRINIC=`ip -o link|grep -i "$PRINIC"|awk  '{print $2}'|sed s/://`
fi
echo 'export PRINIC='"$PRINIC" > /mnt/tmp/prinicsetting

if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
    set +x
fi
} >>/mnt/var/log/xcat/xcat.log 2>&1
]]>

          </source>
        </script>
      </chroot-scripts>
         <post-scripts config:type="list">
        <script>
          <filename>xcat.sh</filename>
          <interpreter>shell</interpreter>
          <debug config:type="boolean">false</debug>
          <source>

<![CDATA[
mkdir -p /var/log/xcat/
{
echo "Running AutoYaST Post-Installation script..."
#!/bin/sh

export XCATDEBUGMODE=""
export MASTER_IP="10.28.0.30"
declare -F msgutil_r &>/dev/null  || function msgutil_r {
   local logserver=$1
   local msgtype=$2
   local msgstr=$3
   local logfile=$4
   local logtag=$5

   if [ -z "$msgtype"  ]; then
      msgtype="debug"
   fi

   if [ -z "$logtag" ]; then
      logtag="xcat"
   fi

   if [ -n "$logserver" ];then
      logger -n $logserver -t $logtag -p local4.$msgtype "$msgstr"
      if [ "$?" != "0" ];then
         exec 3<>/dev/udp/$logserver/514 >/dev/null;logger -s -t $logtag -p local4.$msgtype "$msgstr" 2>&3
         if [ "$?" != "0" ];then
            logger -s -t $logtag -p local4.$msgtype "$msgstr" 2>&1|nc $logserver 514 >/dev/null 2>&1
            if [ "$?" != "0" ];then
               logger -t $logtag -p local4.$msgtype "$msgstr"
            fi
         fi
      fi
   else
       logger -t $logtag -p local4.$msgtype "$msgstr"
   fi
   if [ -n "$logfile"  ]; then
      local logdir="$(dirname $logfile)"
      if [ ! -d "$logdir" ]; then
         mkdir -p "$logdir"
         touch "$logfile"
      fi

      echo "$(date) [$msgtype]: $logtag: $msgstr" >> $logfile
   fi

}

declare -F msgutil &>/dev/null  || function msgutil {
    msgutil_r "" "$@"
}


if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
    set -x
fi

export MANAGEDADDRESSMODE=

cd /etc/sysconfig/network

if [ "$MANAGEDADDRESSMODE" != "static"  ]
then
rm -f ifcfg-eth-id*
rm -f ifcfg-myri*
cat >ifcfg-eth0 <<EOF
DEVICE=eth0
BOOTPROTO=dhcp
STARTMODE=onboot
EOF
fi
. /tmp/prinicsetting
rm /tmp/prinicsetting
if [ "$PRINIC" != "eth0" ]
then
	cd /etc/sysconfig/network
	if [ ! -r ifcfg-$PRINIC ]
	then
#		cp -f ifcfg-eth0 ifcfg-$PRINIC
		mv -f ifcfg-eth0 ifcfg-$PRINIC
		perl -pi -e "s/eth0/$PRINIC/" ifcfg-$PRINIC
#		echo "DHCLIENT_PRIMARY_DEVICE=yes" >> ifcfg-$PRINIC
	fi
fi

if [ "$MANAGEDADDRESSMODE" != "static"  ]
then
echo "DHCLIENT_PRIMARY_DEVICE=yes" >> ifcfg-$PRINIC
fi

perl -pi -e 's/^FIREWALL="yes"/FIREWALL="no"/' /etc/sysconfig/network/config
service network restart

RAND=$(perl -e 'print int(rand(50)). "\n"')
sleep $RAND
jsi=0
while [ $(hostname) == 'linux' ]
do
	if [ $jsi -gt 180 ]; then
		logger "Slept too long!"
		exit
	fi
	let jsi=jsi+1
	sleep 1
done
echo "Slept $jsi seconds before hostname made sense."

HOSTNAME=$(hostname -s)
echo $HOSTNAME

if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
   msgutil_r "$MASTER_IP" "debug" "PRINIC=$PRINIC,HOSTNAME=$HOSTNAME" "/var/log/xcat/xcat.log"
fi
/sbin/portmap

if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
    set +x
fi
#
# Run xCAT post install
#
export MASTER_IP="10.28.0.30"
export MASTER="10.28.0.30"
export NODESTATUS=""
export XCATIPORT=3002
export INSTALLDIR=/install
export TFTPDIR=/tftpboot
export XCATDEBUGMODE=""
export HTTPPORT=""

declare -F msgutil_r &>/dev/null  || function msgutil_r {
   local logserver=$1
   local msgtype=$2
   local msgstr=$3
   local logfile=$4
   local logtag=$5

   if [ -z "$msgtype"  ]; then
      msgtype="debug"
   fi

   if [ -z "$logtag" ]; then
      logtag="xcat"
   fi

   if [ -n "$logserver" ];then
      logger -n $logserver -t $logtag -p local4.$msgtype "$msgstr"
      if [ "$?" != "0" ];then
         exec 3<>/dev/udp/$logserver/514 >/dev/null;logger -s -t $logtag -p local4.$msgtype "$msgstr" 2>&3
         if [ "$?" != "0" ];then
            logger -s -t $logtag -p local4.$msgtype "$msgstr" 2>&1|nc $logserver 514 >/dev/null 2>&1
            if [ "$?" != "0" ];then
               logger -t $logtag -p local4.$msgtype "$msgstr"
            fi
         fi
      fi
   else
       logger -t $logtag -p local4.$msgtype "$msgstr"
   fi
   if [ -n "$logfile"  ]; then
      local logdir="$(dirname $logfile)"
      if [ ! -d "$logdir" ]; then
         mkdir -p "$logdir"
         touch "$logfile"
      fi

      echo "$(date) [$msgtype]: $logtag: $msgstr" >> $logfile
   fi

}

declare -F msgutil &>/dev/null  || function msgutil {
    msgutil_r "" "$@"
}


if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
    set -x
fi

if [ -z "$XCATIPORT" ]; then
    XCATIPORT="3002"
fi
if [ -z "$INSTALLDIR" ]; then
    INSTALLDIR="/install"
fi
if [ -z "$TFTPDIR" ]; then
    TFTPDIR="/tftpboot"
fi
if [[ $TFTPDIR != /* ]]; then
    TFTPDIR="/"$TFTPDIR
fi
if [ -z "$HTTPPORT" ]; then
    HTTPPORT="80"
fi

NODESTATUS=$(echo "$NODESTATUS"| tr -d \'\"| tr A-Z a-z)

(cat  << 'EOF'
#!/usr/bin/awk -f
# IBM(c) 2007 EPL license http://www.eclipse.org/legal/epl-v10.html

BEGIN {
    xcatdhost = ARGV[1]
    xcatdport = ARGV[2]
    flag = ARGV[3]

    if (!flag) flag = "next"

    ns = "/inet/tcp/0/" xcatdhost "/" xcatdport

    loop = 0
    while(1) {
        if((ns |& getline) > 0)
            print $0 | "logger -t xcat -p local4.info"
        else {
            print "Retrying flag update" | "logger -t xcat -p local4.info"
            print "updateflag.awk: Retrying flag update" >> "/var/log/xcat/xcat.log"
            close(ns)
            system("sleep 10")
            loop = loop + 1
        }

        if($0 == "ready")
            print flag |& ns
        if($0 == "done")
            break
        if(loop > 10) {
            print "flag update failed" | "logger -t xcat -p local4.info"
            print "updateflag.awk: flag update failed" >> "/var/log/xcat/xcat.log"
            break
        }
    }

    close(ns)

    exit 0
}

EOF
) >/tmp/updateflag

chmod 0755 /tmp/updateflag

cd /tmp
log_label="xcat.deployment"
msgutil_r "$MASTER_IP" "info" "Executing post.xcat to prepare for firstbooting ..." "/var/log/xcat/xcat.log" "$log_label"

RAND=$(perl -e 'print int(rand(50)). "\n"')
if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
   msgutil_r "$MASTER_IP" "debug" "sleep $RAND" "/var/log/xcat/xcat.log" "$log_label"
fi
sleep $RAND

# Stop if no openssl to help the next bit
if [ ! -x /usr/bin/openssl ]; then
    msgutil_r "$MASTER_IP" "error" "/usr/bin/openssl does not exist, halt ..." "/var/log/xcat/xcat.log" "$log_label"
    /tmp/updateflag $MASTER $XCATIPORT "installstatus failed"
    sleep 36500d
fi

#save to /opt/xcat/xcatinfo file
if [ ! -f /opt/xcat/xcatinfo ]; then
    mkdir -p /opt/xcat
    touch /opt/xcat/xcatinfo
fi

grep 'XCATSERVER' /opt/xcat/xcatinfo > /dev/null 2>&1
if [ $? -eq 0 ]; then
    sed -i "s/XCATSERVER=.*/XCATSERVER=$MASTER_IP/" /opt/xcat/xcatinfo
else
    echo "XCATSERVER=$MASTER_IP" >> /opt/xcat/xcatinfo
fi

grep 'INSTALLDIR' /opt/xcat/xcatinfo > /dev/null 2>&1
if [ $? -eq 0 ]; then
    sed -i "s/INSTALLDIR=.*/INSTALLDIR=$INSTALLDIR/" /opt/xcat/xcatinfo
else
    echo "INSTALLDIR=$INSTALLDIR" >> /opt/xcat/xcatinfo
fi

grep 'HTTPPORT' /opt/xcat/xcatinfo > /dev/null 2>&1
if [ $? -eq 0 ]; then
    sed -i "s/HTTPPORT=.*/HTTPPORT=$HTTPPORT/" /opt/xcat/xcatinfo
else
    echo "HTTPPORT=$HTTPPORT" >> /opt/xcat/xcatinfo
fi

if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
    msgutil_r "$MASTER_IP" "debug" "/opt/xcat/xcatinfo generated" "/var/log/xcat/xcat.log" "$log_label"
fi

# download the postscripts
msgutil_r "$MASTER_IP" "info" "trying to download postscripts from $MASTER_IP..." "/var/log/xcat/xcat.log" "$log_label"

# Stop if no wget to help the next bit
if [ ! -x /usr/bin/wget ]; then
    msgutil_r "$MASTER_IP" "error" "/usr/bin/wget does not exist, halt ..." "/var/log/xcat/xcat.log" "$log_label"
    /tmp/updateflag $MASTER $XCATIPORT "installstatus failed"
    sleep 36500d
fi

wget -l inf -N -r --waitretry=10 --random-wait --retry-connrefused  -e robots=off -nH --cut-dirs=2 --reject "index.html*" --no-parent -t 20 -T 60 http://${MASTER_IP}:${HTTPPORT}${INSTALLDIR}/postscripts/ -P /xcatpost 2> /tmp/wget.log
if [ "$?" != "0" ]; then
    msgutil_r "$MASTER_IP" "error" "failed to download postscripts from http://$MASTER_IP$INSTALLDIR/postscripts/,check /tmp/wget.log on the node,  halt ..." "/var/log/xcat/xcat.log" "$log_label"
    /tmp/updateflag $MASTER $XCATIPORT "installstatus failed"
    sleep 36500d
fi
chmod -R +x `find /xcatpost/ -maxdepth 1 -print | grep -E -v '^(/xcatpost/|/xcatpost/_xcat|/xcatpost/_ssh|/xcatpost/ca|/xcatpost/hostkeys)$'`
msgutil_r "$MASTER_IP" "info" "postscripts downloaded successfully" "/var/log/xcat/xcat.log" "$log_label"

# get the precreated mypostscript file
if [ -x /xcatpost/mypostscript ]; then
    rm -rf /xcatpost/mypostscript
fi
export NODE=c84f1u14

msgutil_r "$MASTER_IP" "info" "trying to get mypostscript from $MASTER_IP..." "/var/log/xcat/xcat.log" "$log_label"

wget -N --waitretry=10 --random-wait --retry-connrefused -t 20 -T 60 http://${MASTER_IP}:${HTTPPORT}${TFTPDIR}/mypostscripts/mypostscript.$NODE  -P /xcatpost 2> /tmp/wget.log
if [ "$?" = "0" ]; then
    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "debug" "precreated mypostscript downloaded successfully" "/var/log/xcat/xcat.log" "$log_label"
    fi
    mv /xcatpost/mypostscript.$NODE /xcatpost/mypostscript
    chmod 700 /xcatpost/mypostscript
fi

USEOPENSSLFORXCAT=1 #Though this is the only method going forward, flag to allow backward compatibility with 2.2 generated netboot images
export USEOPENSSLFORXCAT
XCATSERVER=$MASTER_IP:3001
export XCATSERVER

# If mypostscript doesn't exist, we will get it through getpostscript.awk
if [ ! -x /xcatpost/mypostscript ]; then
    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "debug" "no pre-generated mypostscript.<nodename>, trying to get it with getpostscript.awk..." "/var/log/xcat/xcat.log" "$log_label"
    fi

    # To support the postscripts in the subdirectories under /install/postscripts
    # chmod +x /xcatpost/*
    # Stop if no getpostscript.awk to help the next bit
    if [ ! -x /xcatpost/getpostscript.awk ]; then
        msgutil_r "$MASTER_IP" "error" "/xcatpost/getpostscript.awk does not exist, halt ..." "/var/log/xcat/xcat.log" "$log_label"
        /tmp/updateflag $MASTER $XCATIPORT "installstatus failed"
        sleep 36500d
    fi
    /xcatpost/getpostscript.awk |egrep '<data>'|sed -e 's/<[^>]*>//g'|egrep -v '^ *$'|sed -e 's/^ *//' | sed -e 's/&lt;/</g' -e 's/&gt;/>/g' -e 's/&amp;/\&/g' -e 's/&quot;/"/g' -e "s/&apos;/'/g" > /xcatpost/mypostscript

    MYCONT=`grep ^MASTER= /xcatpost/mypostscript`
    RETRY=0
    while [ -z "$MYCONT" ]; do
        RETRY=$(($RETRY+1))
        if [ $RETRY -eq "10" ]; then
            break
        fi

        let SLI=$RANDOM%10+10
        sleep $SLI
        /xcatpost/getpostscript.awk |egrep '<data>'|sed -e 's/<[^>]*>//g'|egrep -v '^ *$'|sed -e 's/^ *//' | sed -e 's/&lt;/</g' -e 's/&gt;/>/g' -e 's/&amp;/\&/g' -e 's/&quot;/"/g' -e "s/&apos;/'/g" > /xcatpost/mypostscript

        MYCONT=`grep ^MASTER= /xcatpost/mypostscript`
    done
fi

TMP=`sed "/^#\s*postscripts-start-here/,/^#\s*postscripts-end-here/ s/\(.*\)/run_ps postscript \1/;s/run_ps postscript\s*#/#/;s/run_ps postscript\s*$//" /xcatpost/mypostscript`
echo "$TMP" > /xcatpost/mypostscript
TMP=`sed "/^#\s*postbootscripts-start-here/,/^#\s*postbootscripts-end-here/ s/\(.*\)/run_ps postbootscript \1/;s/run_ps postbootscript\s*#/#/;s/run_ps postbootscript\s*$//" /xcatpost/mypostscript`

cd /xcatpost
#gunzip xcatpost.tar.gz
#tar -xvf xcatpost.tar
#/xcatpost/c84f1u14
export PATH=$PATH:/xcatpost

# use the run_ps subroutine to run the postscripts

if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
    echo "set -x" > /xcatpost/mypostscript
else
    cat /dev/null > /xcatpost/mypostscript
fi

echo "

. /xcatpost/xcatlib.sh

# global value to store the running status of the postbootscripts,the value is non-zero if one postbootscript failed
return_value=0

# subroutine used to run postscripts
# \$1 argument is the script type
# rest argument is the script name and arguments
run_ps () {
    local ret_local=0
    mkdir -p "\"/var/log/xcat\""
    # On some Linux distro, the rsyslogd daemon write log files with permision
    # other than root:root. And in some case, the directory /var/log/xcat was
    # created by xCAT, and had root:root ownership. In this way, rsyslogd
    # did not have enough permission to write to log files under this directory.
    # As a dirty hack, change the ownership of directory /var/log/xcat to the
    # same ownership of directory /var/log.
    chown `ls -ld /var/log | awk '{ print \$3\":\"\$4 }'` "\"/var/log/xcat\""
    local logfile=\"/var/log/xcat/xcat.log\"
    local scriptype=\$1
    shift;

    if [ -z \"\$scriptype\" ]; then
        scriptype=\"postscript\"
    fi
    log_label=\"xcat.deployment.\"\$scriptype
    export LOGLABEL=\$log_label
    if [ -f \$1 ]; then
        msgutil_r \"\$MASTER_IP\" \"info\" "\"\$scriptype start..: \$1\"" \"\$logfile\" \"\$log_label\"
        if [ \"\$XCATDEBUGMODE\" = \"1\" ] || [ \"\$XCATDEBUGMODE\" = \"2\" ]; then
            local compt=\$(file \$1)
            local reg=\"shell script\"
            if [[ \"\$compt\" =~ \$reg ]]; then
                bash -x ./\$@ 2>&1
                ret_local=\$?
            else
                ./\$@ 2>&1 | logger -t \$log_label -p debug
                ret_local=\${PIPESTATUS[0]}
            fi
        else
            ./\$@ 2>&1
            ret_local=\${PIPESTATUS[0]}
        fi

        if [ \"\$ret_local\" -ne \"0\" ]; then
            return_value=\$ret_local
        fi
        msgutil_r \"\$MASTER_IP\" \"info\" "\"\$scriptype end...: \$1 return with \$ret_local\"" \"\$logfile\" \"\$log_label\"
    else
        msgutil_r \"\$MASTER_IP\" \"error\" "\"\$scriptype \$1 does NOT exist.\"" \"\$logfile\" \"\$log_label\"
        return_value=-1
    fi


    return 0
}
# subroutine end

" >> /xcatpost/mypostscript
echo "$TMP" >> /xcatpost/mypostscript

if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
    echo "set +x" >> /xcatpost/mypostscript
fi

chmod +x /xcatpost/mypostscript
if [ ! -x /xcatpost/mypostscript ]; then
    msgutil_r "$MASTER_IP" "error" "failed to generate mypostscript file, halt ..." "/var/log/xcat/xcat.log" "$log_label"
    /tmp/updateflag $MASTER $XCATIPORT "installstatus failed"
    sleep 36500d
else
    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "debug" "generate mypostscript file successfully" "/var/log/xcat/xcat.log" "$log_label"
    fi
fi


#save the postboot scripts to /xcatpost/mypostscript.post
TMP=`sed "/^#\s*postscripts-start-here/,/^#\s*postscripts-end-here/ d" /xcatpost/mypostscript`
echo "$TMP" > /xcatpost/mypostscript.post
chmod 755 /xcatpost/mypostscript.post

if [ ! -x /xcatpost/mypostscript.post ]; then
    msgutil_r "$MASTER_IP" "error" "failed to generate /xcatpost/mypostscript.post" "/var/log/xcat/xcat.log" "$log_label"
else
    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "debug" "generate mypostscript.post file successfully" "/var/log/xcat/xcat.log" "$log_label"
    fi
fi


export OSVER=sle15
#create the post init service as a hook to run PS and PBS, as well as status updating
hassystemd=0
systemctl --version 2>/dev/null
if [ $? -eq 0 ]; then
    hassystemd=1
fi

if [ $hassystemd -eq 1 ] ; then
    if [[ $OSVER =~ sle && $OSVER != sles11* ]]; then
        cat >/etc/systemd/system/xcatpostinit1.service <<'EOF'
[Unit]
Description=xcat service on compute node, the framework to run postbootscript during OS provision
After=network.target rsyslog.service YaST2-Firstboot.service

[Service]
Type=oneshot
ExecStart=/opt/xcat/xcatpostinit1 start
ExecStop=/opt/xcat/xcatpostinit1 stop
StandardOutput=null
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
        cat >/opt/xcat/xcatpostinit1.service.sles <<'EOF'
[Unit]
Description=xcat service on compute node, the framework to run postbootscript and update node status
After=network.target rsyslog.service

[Service]
Type=oneshot
ExecStart=/opt/xcat/xcatpostinit1 start
ExecStop=/opt/xcat/xcatpostinit1 stop
StandardOutput=null
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
    else
        cat >/etc/systemd/system/xcatpostinit1.service <<'EOF'
[Unit]
Description=xcat service on compute node, the framework to run postbootscript and update node status
After=network.target rsyslog.service

[Service]
Type=oneshot
ExecStart=/opt/xcat/xcatpostinit1 start
ExecStop=/opt/xcat/xcatpostinit1 stop
StandardOutput=null
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
    fi
    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "debug" "/etc/systemd/system/xcatpostinit1.service generated" "/var/log/xcat/xcat.log" "$log_label"
    fi

    ln -s /etc/systemd/system/xcatpostinit1.service /etc/systemd/system/multi-user.target.wants/xcatpostinit1.service

    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "debug" "xcatpostinit1.service enabled" "/var/log/xcat/xcat.log" "$log_label"
    fi
    cat >/opt/xcat/xcatpostinit1 << 'EOF'
#!/bin/bash
# IBM(c) 2007 EPL license http://www.eclipse.org/legal/epl-v10.html
# chkconfig: 345 84 59
# description: the hook for systemd service unit to run PB and report node status on diskful node
# processname: xcatpostinit1

### BEGIN INIT INFO
# Provides:             xcatpostinit1
# Required-Start:       $network $syslog
# Should-Start:
# Required-Stop:        $network $syslog
# Should-Stop:
# Default-Start:        3 4 5
# Default-Stop:         0 1 2 6
# Short-Description:    hook to run xcat PBS and report node status
# Description:
### END INIT INFO

# Source function library.
if [ -x /etc/rc.d/init.d/functions ]; then
  . /etc/rc.d/init.d/functions
fi

[ -f /opt/xcat/xcatinfo ] && XCATSERVER=`grep 'XCATSERVER' /opt/xcat/xcatinfo |cut -d= -f2 | tr -d \'\" `
[ -f /xcatpost/mypostscript ] && NODESTATUS=`grep 'NODESTATUS=' /xcatpost/mypostscript |awk -F = '{print $2}'|tr -d \'\" | tr A-Z a-z `
[ -z "$NODESTATUS" ] && NODESTATUS="1"
[ -f /xcatpost/mypostscript ] && RUNBOOTSCRIPTS=`grep 'RUNBOOTSCRIPTS=' /xcatpost/mypostscript |awk -F = '{print $2}' | tr -d \'\" | tr A-Z a-z `

case $1 in
stop)
  [ "$NODESTATUS" != "n" ] &&  /xcatpost/updateflag.awk $XCATSERVER 3002 "installstatus powering-off"
  ;;
start)
  # check for the REBOOT specified in xcatinfo to run post boot scripts on reboot
  if [ -f /opt/xcat/xcatinfo ]; then
    REBOOT=`grep 'REBOOT' /opt/xcat/xcatinfo |cut -d= -f2 | tr -d \'\"`
  fi
  # if the xcatdsklspost file exists and this is a reboot - run xcatdsklspost with a mode of 6
  if [ "$REBOOT" = "TRUE" -a -r /opt/xcat/xcatdsklspost ] && [[ "$RUNBOOTSCRIPTS" =~ ^(1|yes|y)$ ]]; then
      [ "$NODESTATUS" != "n" ] &&  /xcatpost/updateflag.awk $XCATSERVER 3002 "installstatus postbooting"
      # xcatdsklspost will set the status to 'booted' or 'failed'
      /opt/xcat/xcatdsklspost 6
  elif [ "$REBOOT" = "TRUE" ] && [[ "$NODESTATUS" =~  ^(1|yes|y)$ ]]; then
      /xcatpost/updateflag.awk $XCATSERVER 3002 "installstatus booted"
  else
    [ "$NODESTATUS" != "n" ] &&  /xcatpost/updateflag.awk $XCATSERVER 3002 "installstatus postbooting"
    # run /opt/xcat/xcatinstallpost, it will set the status to 'booted' or 'failed'
    if [ -r /opt/xcat/xcatinstallpost ]; then
      /opt/xcat/xcatinstallpost
    fi
    if [ -f /opt/xcat/xcatpostinit1.service.sles ]; then
        rm -rf /etc/systemd/system/xcatpostinit1.service
        mv /opt/xcat/xcatpostinit1.service.sles /etc/systemd/system/xcatpostinit1.service
    fi
  fi

  ;;
esac
EOF
    chmod 755 /opt/xcat/xcatpostinit1
else
    cat >/etc/init.d/xcatpostinit1 << 'EOF'
#!/bin/bash
# IBM(c) 2007 EPL license http://www.eclipse.org/legal/epl-v10.html
# chkconfig: 345 84 59
# description: the hook for systemd service unit to run PB and report node status on diskful node
# processname: xcatpostinit1

### BEGIN INIT INFO
# Provides:             xcatpostinit1
# Required-Start:       $network $syslog
# Should-Start:
# Required-Stop:        $network $syslog
# Should-Stop:
# Default-Start:        3 4 5
# Default-Stop:         0 1 2 6
# Short-Description:    hook to run xcat PBS and report node status
# Description:
### END INIT INFO

# Source function library.
if [ -x /etc/rc.d/init.d/functions ]; then
  . /etc/rc.d/init.d/functions
fi

[ -f /opt/xcat/xcatinfo ] && XCATSERVER=`grep 'XCATSERVER' /opt/xcat/xcatinfo |cut -d= -f2 | tr -d \'\" `
[ -f /xcatpost/mypostscript ] && NODESTATUS=`grep 'NODESTATUS=' /xcatpost/mypostscript |awk -F = '{print $2}'|tr -d \'\" | tr A-Z a-z `
[ -z "$NODESTATUS" ] && NODESTATUS="1"
[ -f /xcatpost/mypostscript ] && RUNBOOTSCRIPTS=`grep 'RUNBOOTSCRIPTS=' /xcatpost/mypostscript |awk -F = '{print $2}' | tr -d \'\" | tr A-Z a-z `

case $1 in
stop)
  [ "$NODESTATUS" != "n" ] &&  /xcatpost/updateflag.awk $XCATSERVER 3002 "installstatus powering-off"
  ;;
start)
  # check for the REBOOT specified in xcatinfo to run post boot scripts on reboot
  if [ -f /opt/xcat/xcatinfo ]; then
    REBOOT=`grep 'REBOOT' /opt/xcat/xcatinfo |cut -d= -f2 | tr -d \'\"`
  fi
  # if the xcatdsklspost file exists and this is a reboot - run xcatdsklspost with a mode of 6
  if [ "$REBOOT" = "TRUE" -a -r /opt/xcat/xcatdsklspost ] && [[ "$RUNBOOTSCRIPTS" =~ ^(1|yes|y)$ ]]; then
      [ "$NODESTATUS" != "n" ] &&  /xcatpost/updateflag.awk $XCATSERVER 3002 "installstatus postbooting"
      # xcatdsklspost will set the status to 'booted' or 'failed'
      /opt/xcat/xcatdsklspost 6
  elif [ "$REBOOT" = "TRUE" ] && [[ "$NODESTATUS" =~  ^(1|yes|y)$ ]]; then
      /xcatpost/updateflag.awk $XCATSERVER 3002 "installstatus booted"
  else
    [ "$NODESTATUS" != "n" ] &&  /xcatpost/updateflag.awk $XCATSERVER 3002 "installstatus postbooting"
    # run /opt/xcat/xcatinstallpost, it will set the status to 'booted' or 'failed'
    if [ -r /opt/xcat/xcatinstallpost ]; then
      /opt/xcat/xcatinstallpost
    fi
    if [ -f /opt/xcat/xcatpostinit1.service.sles ]; then
        rm -rf /etc/systemd/system/xcatpostinit1.service
        mv /opt/xcat/xcatpostinit1.service.sles /etc/systemd/system/xcatpostinit1.service
    fi
  fi

  ;;
esac
EOF
    chmod 755 /etc/init.d/xcatpostinit1

    if [ ! -x /etc/init.d/xcatpostinit1 ]; then
        msgutil_r "$MASTER_IP" "error" "failed to generate /etc/init.d/xcatpostinit1" "/var/log/xcat/xcat.log" "$log_label"
    else
        if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
            msgutil_r "$MASTER_IP" "debug" "/etc/init.d/xcatpostinit1 generated" "/var/log/xcat/xcat.log" "$log_label"
        fi
    fi

    if [[ $OSVER == ubuntu* ]]; then
        ln -s /etc/init.d/xcatpostinit1 /etc/rc2.d/S84xcatpostinit1
    else
        ln -s /etc/init.d/xcatpostinit1 /etc/rc.d/rc3.d/S84xcatpostinit1
        ln -s /etc/init.d/xcatpostinit1 /etc/rc.d/rc4.d/S84xcatpostinit1
        ln -s /etc/init.d/xcatpostinit1 /etc/rc.d/rc5.d/S84xcatpostinit1
    fi

    if [[ $OSVER == ubuntu* ]]; then
        update-rc.d xcatpostinit1 defaults
    else
        if [[ $OSVER == sle* ]]; then
            if [[ $OSVER == sles10* ]]; then
                /sbin/insserv xcatpostinit1
            else
                /sbin/insserv -p /etc/init.d xcatpostinit1
            fi
        fi
        #chkconfig --add xcatpostinit1
        chkconfig xcatpostinit1 on
        if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
            msgutil_r "$MASTER_IP" "debug" "service xcatpostinit1 enabled" "/var/log/xcat/xcat.log" "$log_label"
        fi
    fi
fi

#create the xcatinstallpost
mkdir -p /opt/xcat
cat >/opt/xcat/xcatinstallpost << 'EOF'
#!/bin/bash
# IBM(c) 2007 EPL license http://www.eclipse.org/legal/epl-v10.html
#################################################################
#
#   xCAT script for running postboot scripts for full install case.
#################################################################

. /xcatpost/xcatlib.sh
log_label="xcat.deployment"
if [ -f /xcatpost/mypostscript.post ]; then
    XCATDEBUGMODE=`grep 'XCATDEBUGMODE=' /xcatpost/mypostscript.post |cut -d= -f2 | tr -d \'\" | tr A-Z a-z `
    MASTER_IP=`grep '^MASTER_IP=' /xcatpost/mypostscript.post |cut -d= -f2|sed s/\'//g`
    OSVER=`grep '^OSVER=' /xcatpost/mypostscript.post |cut -d= -f2|sed s/\'//g`
    NODE=`grep '^NODE=' /xcatpost/mypostscript.post |cut -d= -f2|sed s/\'//g`
    IMAGE=`grep '^PROVMETHOD=' /xcatpost/mypostscript.post |cut -d= -f2|sed s/\'//g`
fi


if [ ! `uname` = Linux ]; then
   msgutil_r "$MASTER_IP" "error" "The OS is not Linux" "/var/log/xcat/xcat.log" "$log_label"
   exit
fi
SLI=$(awk 'BEGIN{srand(); printf("%d\n",rand()*10)}')
sleep $SLI

XCATINFOFILE=/opt/xcat/xcatinfo
MACADDR=`grep MACADDRESS= /xcatpost/mypostscript.post | awk -F = '{ print $2 }'| sed "s/\'//g"`
INSTALLNIC=`ip -o link | grep -i "$MACADDR" | awk '{ print $2 }' | sed "s/://"`


# the network between the node and MASTER might be not well configured and activated when running the PBS sometimes
# need to make sure...
RETRY=0
while true; do
    #check whether the network access between MN/CN and the node is ready
    ping $MASTER_IP -c 1 >/dev/null && break

    RETRY=$[ $RETRY + 1 ]

    if [ $RETRY -eq 90 ];then
       #timeout, complain and exit
       msgutil_r "$MASTER_IP" "error" "the network between the node and $MASTER_IP is not ready, please check[retry=$RETRY]..." "/var/log/xcat/xcat.log" "$log_label"
       exit 1
    fi

    #sleep sometime before the next scan
    sleep 2
done


cd /xcatpost;
PATH=/xcatpost:$PATH
export PATH
# To support the postscripts in the subdirectories under /install/postscripts
#chmod +x /xcatpost/*;
chmod -R +x `find /xcatpost/ -maxdepth 1 -print | grep -E -v '^(/xcatpost/|/xcatpost/_xcat|/xcatpost/_ssh|/xcatpost/ca|/xcatpost/hostkeys)$'`

POST_IN_DIR="/xcatpost"

if [ -x /usr/bin/openssl ]; then
     SIP=`grep "^MASTER=" ${POST_IN_DIR}/mypostscript.post  |cut -d= -f2`
     XCATSERVER="$SIP:3001"
     export XCATSERVER
     USEOPENSSLFORXCAT=1 #Though this is the only method going forward, flag to allow backward compatibility with 2.2 generated netboot images
     export USEOPENSSLFORXCAT
fi

#  Regardless of where mypostscript.post was found, modify and run it in /xcatpost.

DHCP_TMP=`sed 's/\(DHCPINTERFACES=\)\(.*\)$/\1"\2"/' /xcatpost/mypostscript.post`
echo "$DHCP_TMP" > /xcatpost/mypostscript.post

#mark that the first reboot after installation is finished
grep 'REBOOT' /opt/xcat/xcatinfo > /dev/null 2>&1
if [ $? -eq 0 ]; then
    sed -i "s/REBOOT=.*/REBOOT=TRUE/" /opt/xcat/xcatinfo
else
    echo "REBOOT=TRUE" >> /opt/xcat/xcatinfo
fi

#add node name to xcatinfo
grep 'NODE' /opt/xcat/xcatinfo > /dev/null 2>&1
if [ $? -eq 0 ]; then
    sed -i "s/NODE=.*/NODE=$NODE/" /opt/xcat/xcatinfo
else
    echo "NODE=$NODE" >> /opt/xcat/xcatinfo
fi

#add image name to xcatinfo
grep 'IMAGENAME' /opt/xcat/xcatinfo > /dev/null 2>&1
if [ $? -eq 0 ]; then
    sed -i "s/IMAGENAME=.*/IMAGENAME=$IMAGE/" /opt/xcat/xcatinfo
else
    echo "IMAGENAME=$IMAGE" >> /opt/xcat/xcatinfo
fi

# Store the SERVICEGROUP into the xcatinfo file for statful installation
sn_group=`grep '^SERVICEGROUP' /xcatpost/mypostscript |cut -d= -f2 | tr -d \'\"`
if [ "x" != "x$sn_group" ]; then
  # Change or add SERVICEGROUP line if service node pool defined.
  grep 'SERVICEGROUP=' $XCATINFOFILE > /dev/null 2>&1
  if [ $? -eq 0 ]; then
    sed -i "s/SERVICEGROUP=.*/SERVICEGROUP=$sn_group/" $XCATINFOFILE
  else
    echo "SERVICEGROUP=$sn_group" >> $XCATINFOFILE
  fi
else
  # Remove SERVICEGROUP line if no service node pool defined.
  sed -i "/SERVICEGROUP=.*/d" $XCATINFOFILE
fi

[ -f /xcatpost/mypostscript ] && NODESTATUS=`grep 'NODESTATUS=' /xcatpost/mypostscript |awk -F = '{print $2}'|tr -d \'\" | tr A-Z a-z `
[ -z "$NODESTATUS" ] && NODESTATUS="1"

CNS=$NODESTATUS
if [ -z "$CNS" ] || [[ "$CNS" =~ ^(1|yes|y)$ ]]; then
#update the node status during the postbootscript running
#TMP=`sed "/postbootscripts-start-here/ i\updateflag.awk \\$MASTER 3002 \\"installstatus configuring\\"" /xcatpost/mypostscript.post`
#echo "$TMP"> /xcatpost/mypostscript.post

echo "

[ -f /opt/xcat/xcatinfo ] && grep 'POSTSCRIPTS_RC=1' /opt/xcat/xcatinfo >/dev/null 2>&1 && return_value=1


if [ \"\$return_value\" -eq \"0\" ]; then
    if [ \"\$XCATDEBUGMODE\" = \"1\" ] || [ \"\$XCATDEBUGMODE\" = \"2\" ]; then
        msgutil_r \"\$MASTER_IP\" \"debug\" \"node booted, reporting status...\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
    fi
    updateflag.awk \$MASTER 3002 \"installstatus booted\"
    msgutil_r \$MASTER_IP \"info\" \"provision completed.(\$NODE)\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
else
    if [ \"\$XCATDEBUGMODE\" = \"1\" ] || [ \"\$XCATDEBUGMODE\" = \"2\" ]; then
        msgutil_r \"\$MASTER_IP\" \"debug\" \"node boot failed, reporting status...\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
    fi
    updateflag.awk \$MASTER 3002 \"installstatus failed\"
    msgutil_r \$MASTER_IP \"error\" \"provision completed with error.(\$NODE)\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
fi
" >> /xcatpost/mypostscript.post
fi


chmod +x /xcatpost/mypostscript.post
if [ -x /xcatpost/mypostscript.post ];then
   msgutil_r "$MASTER_IP" "info" "Running /xcatpost/mypostscript.post" "/var/log/xcat/xcat.log" "$log_label"
   /xcatpost/mypostscript.post
   msgutil_r "$MASTER_IP" "info" "/xcatpost/mypostscript.post return" "/var/log/xcat/xcat.log" "$log_label"
   msgutil_r "$MASTER_IP" "info" "=============deployment ending====================" "/var/log/xcat/xcat.log" "$log_label"
fi

if [ -f /xcatpost/mypostscript.post ]; then
    RUNBOOTSCRIPTS=`grep 'RUNBOOTSCRIPTS=' /xcatpost/mypostscript.post |cut -d= -f2 | tr -d \'\" | tr A-Z a-z`
fi

if [[ $OSVER == ubuntu* ]]; then
    if [[ ! "$RUNBOOTSCRIPTS" =~ ^(1|yes|y)$ ]]; then
        update-rc.d -f xcatpostinit1 remove
    fi
    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "debug" "update-rc.d -f xcatpostinit1 remove" "/var/log/xcat/xcat.log" "xcat.xcatinstallpost"
    fi
else
    if [[ ! "$RUNBOOTSCRIPTS" =~ ^(1|yes|y)$ ]] && [[ ! "$NODESTATUS" =~ ^(1|yes|y)$ ]]; then
        chkconfig xcatpostinit1 off
        if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
            msgutil_r "$MASTER_IP" "debug" "service xcatpostinit1 disabled" "/var/log/xcat/xcat.log" "xcat.xcatinstallpost"
        fi
    fi

fi

EOF
chmod 755 /opt/xcat/xcatinstallpost

if [ ! -x /opt/xcat/xcatinstallpost ]; then
    msgutil_r "$MASTER_IP" "error" "failed to generate /opt/xcat/xcatinstallpost" "/var/log/xcat/xcat.log" "$log_label"
else
    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "debug" "/opt/xcat/xcatinstallpost generated" "/var/log/xcat/xcat.log" "$log_label"
    fi
fi


#create the dskls post
cat >/opt/xcat/xcatdsklspost << 'EOF'
#!/bin/bash
# IBM(c) 2007 EPL license http://www.eclipse.org/legal/epl-v10.html
#####################################################
#
#   Generic xCAT post script for diskless nodes
#   The syntax of this script:
#      xcatdsklspost {mode} {-m|-M} [postscripts] --tftp /tftpboot --installdir /install --nfsv4 no -c -V
#   This script is called in the following different places:
#      updatenode -P ... --> xcatdsklspost 1 -m/-M ...
#      updatenode -S --> xcatdsklspost 2 -m/-M otherpkgs
#      moncfg rmcmon --> xcatdsklspost 3 configrmcnodes
#      node deployment  --> xcatdsklspost
#      statelite mode   --> xcatdsklspost 4
#      update security  --> xcatdsklspost 5 -m/-M ...
#      node reboot - xcatpostinit1  --> xcatdsklspost 6
# This script has a debug mode,  if XCATDEBUG env variable is set, then
#   /xcatpost becomes /xcatpost.<nodename>.  This allow running multiple
#   instances of the script to simulate many node on one physical node
#
#####################################################

[ -f "/xcatpost/xcatlib.sh" ] &&  . /xcatpost/xcatlib.sh

if [ -f /xcatpost/mypostscript.post ]; then
    XCATDEBUGMODE=`grep 'XCATDEBUGMODE=' /xcatpost/mypostscript.post | cut -d= -f2 | tr -d \'\" | tr A-Z a-z`
    MASTER_IP=`grep '^MASTER_IP=' /xcatpost/mypostscript.post |cut -d= -f2|sed s/\'//g`
    NODE=`grep '^NODE=' /xcatpost/mypostscript.post |cut -d= -f2|sed s/\'//g`
else
    for param in `cat /proc/cmdline`; do
            key=`echo $param|awk -F= '{print $1}'`
            if [ "$key" = "xcatdebugmode" ]; then
                    XCATDEBUGMODE=`echo $param|awk -F= '{print $2}'| tr -d \'\" | tr A-Z a-z`
            fi

            if [ "$key" = "LOGSERVER" ]; then
                    MASTER_IP=`echo $param|awk -F= '{print $2}'`
            fi
    done
fi

XCATINFOFILE=/opt/xcat/xcatinfo

#echolog: process message log and echo in xcatdsklspost
#arguments:
#          msgtype: message type, valid values:debug,info,warning,err
#          msgstr : the string of message
#description:
#          echo messages only when ($msgtype != debug) or ($msgtype = debug && $VERBOSE = 1)
#          log "debug" messages only when (site.xcatdebugmode=1),log all messages with other types
#          append the "debug" messages to "/var/log/xcat/xcat.log" when (site.xcatdebugmode=1)
#          append all the other type messages  to "/var/log/xcat/xcat.log"
echolog()
{
   local msgtype=$1
   local msgstr=$2
   local ismsgutil_r=1

   #if msgutil_r is not defined, when no /xcatpost directory exists on the node running this script
   #write the message to local log file as a simplified function
   type -t msgutil_r >/dev/null || ismsgutil_r=0
   [ "$ismsgutil_r" = "0" ]  && msgutil_r () {
                                    echo "$(date) [$2]: $3" >> $4
                                }


   if [ "$msgtype" = "debug"  ];then
      if [ "$VERBOSE" = "1"  ]; then
         echo "$msgstr"
      fi
      if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
            msgutil_r  "$MASTER_IP" "$msgtype" "$msgstr" "/var/log/xcat/xcat.log" "$log_label"
      fi
   else
      echo "$msgstr"
      msgutil_r "$MASTER_IP"  "$msgtype" "$msgstr" "/var/log/xcat/xcat.log" "$log_label"
   fi

   #reload the functions defined in./xcatlib.sh
   if [ "$ismsgutil_r" = "0" ];then
       unset msgutil_r
       [ -f ./xcatlib.sh ] && source ./xcatlib.sh
   fi
}


download_postscripts()
{
    server=$1
    if [ -z $server ]; then
        return 1;
    fi

    # Do not override the parameter --installdir
    if [ -z "$INSTALLDIR" ]; then
        if [ -f /opt/xcat/xcatinfo ]; then
           INSTALLDIR=`grep 'INSTALLDIR' /opt/xcat/xcatinfo |cut -d= -f2`
        fi
        if [ -z "$INSTALLDIR" ]; then
            INSTALLDIR="/install"
        fi
    fi
    echolog "debug" "trying to download postscripts from http://$server$INSTALLDIR/postscripts/"
    max_retries=5
    retry=0
    rc=1  # this is a fail return
    while [ 0 -eq 0 ]; do
        if [ -e "$xcatpost" ]; then
            rm -rf "$xcatpost"
        fi

        export LANG=C; wget -l inf -nH -N -r --waitretry=10 --random-wait -e robots=off -T 60 -nH --cut-dirs=2 --reject "index.html*" --no-parent http://$server$INSTALLDIR/postscripts/ -P /$xcatpost 2> /tmp/wget.log
        rc=$?
        if [ $rc -eq 0 ]; then
            # return from wget was 0 but some OS do not return errors, so we
            # have additional checks for
            # failed: Connection httpd not running
            # 404: Not Found  - if directory does not exist
            grep -i -E "... failed: Connection refused.$" /tmp/wget.log
            rc1=$?
            grep -i -E "ERROR 404: Not Found.$" /tmp/wget.log
            rc2=$?
            # check to see no errors at all, grep returns 1
            if [ $rc1 -eq 1 ] && [ $rc2 -eq 1 ]; then
              echolog "debug" "postscripts are downloaded from $server successfully."
              return 0
            fi
        fi

        retry=$(($retry+1))
        echolog "debug" "download_postscripts retry $retry"
        if [ $retry -eq $max_retries ]; then
            echolog "debug" "failed to download postscripts from http://$server$INSTALLDIR/postscripts/ after several retries."
            break
        fi

        SLI=$(awk 'BEGIN{srand(); printf("%d\n",rand()*20)}')
        sleep $SLI
    done
    return $rc
}


download_mypostscript()
{
    server=$1
    node=$2
    max_retries=$3
    TFTPDIR=$4
    if [ -z $server ]; then
      return 1;
    fi
    if [ -z "$TFTPDIR" ]; then
        TFTPDIR="/tftpboot"
    fi
    retry=0
    rc=1


    echolog "debug" "trying to download http://$server$TFTPDIR/mypostscripts/mypostscript.$node..."
    while [ 0 -eq 0 ]; do
        wget -N --waitretry=10 --random-wait -T 60 http://$server$TFTPDIR/mypostscripts/mypostscript.$node -P /$xcatpost 2>> /tmp/wget.log
        rc=$?
        # if no error and the file  was downloaded
        if [ $rc -eq 0 ] && [ -f /$xcatpost/mypostscript.$node ]; then
            mv /$xcatpost/mypostscript.$node /$xcatpost/mypostscript
            echolog "debug" "mypostscript.$node is downloaded successfully."
            return 0
        fi


        retry=$(($retry+1))
        if [ $retry -eq $max_retries ]; then
            echolog "debug" "http://$server$TFTPDIR/mypostscripts/mypostscript.$node is not available."
            break
        fi

    done
    return $rc
}



# pmatch determines if 1st argument string is matched by 2nd argument pattern

pmatch ()
{
  case $1 in
    $2) return 0;;  # zero return code means string matched by pattern
  esac

  return 1          # non-zero return code means string not matched by pattern
}

#parse the http server "<ip/hostname>:<port>"
#usgae: parsehttpserver(<http server string>,<what to return? 'server' or 'port'>)
parsehttpserver ()
{
   rawserver=$1
   option=$2
   server=$(echo "$rawserver"|cut -d: -f1 -s 2>/dev/null)
   port="80"
   if [ -z "$server"  ];then
       server=$rawserver
   else
       port=$(echo "$rawserver"|cut -d: -f2 -s 2>/dev/null)
   fi

   if [ "$option" = "server" ];then
       echo "$server"
   fi

   if [ "$option" = "port" ];then
       echo "$port"
   fi
}

# Main
# parse the arguments
log_label="xcat.updatenode"
ARGNUM=$#;
if [ -z $1 ]; then
  NODE_DEPLOYMENT=1
  log_label="xcat.deployment"
else
  NODE_DEPLOYMENT=0
  case $1 in
    1|2|5)
      MODE=$1
      if [ $ARGNUM -gt 1 ]; then
        if [ $2 = "-m" ]; then
          P_SVR=$3
          P_SIP=$(parsehttpserver "$P_SVR" 'server')
          HTTPPORT=$(parsehttpserver "$P_SVR" 'port')
        else
          if [ $2 = "-M" ]; then
            P_SVR=$3
            P_SIP=$(parsehttpserver "$P_SVR" 'server')
            HTTPPORT=$(parsehttpserver "$P_SVR" 'port')
            new_ms=$P_SIP    # -M means we will update xcatinfo file XCATSERVER
          fi
        fi
      fi
      if [ $ARGNUM -gt 3 ]; then
        POSTSCRIPTS=$4
      fi
      if [ $ARGNUM -gt 4 ]; then
        if [ $5 = "--tftp" ]; then
          TFTPDIR=$6
        fi
      fi
      if [ $ARGNUM -gt 6 ]; then
        if [ $7 = "--installdir" ]; then
          INSTALLDIR=$8
        fi
      fi
      if [ $ARGNUM -gt 8 ]; then
        if [ $9 = "--nfsv4" ]; then
          NFSV4=${10}
        fi
      fi
      if [ $ARGNUM -gt 10 ]; then
        if [ ${11} = "-c" ]; then
          CFLAG=${11}
        fi
      fi
      if [ $ARGNUM -gt 11 ]; then
        if [ ${12} = "-V" ]; then
         export VERBOSE=1
        fi
        if [ ${12} = "-F" ]; then
         export USEFLOWCONTROL=1
        fi
      fi
      if [ $ARGNUM -gt 12 ]; then
        if [ ${13} = "-V" ]; then
         export VERBOSE=1
        fi
      fi
      ;;
    4)
      MODE=$1
      log_label="xcat.deployment"
      ;;
    3|6) MODE=$1;;
  esac
fi

# The cheat sheet for ${MODE}
# Empty
#   node deployment
# 1 - updatenode -P
#   Execute postscripts listed in the postscripts table or parameters
# 2 - updatenode -S
#   Perform Software Maintenanc - updatenode -S
# 3 - moncfg rmcmon
#   Obsoleted
# 4
#   Statelite mode
# 5
#   Update security
# 6 - xcatpostinit1
#   During node reboot
case "${MODE}" in
"1"|"2"|"5")
  # The cheat sheet for checkservicestatus
  # Return code
  # 0 - active
  # 1 - inactive
  # 2 - failed
  # 3 - others
  # 17 - activating
  # 127 - error
  checkservicestatus xcatpostinit1 >/dev/null 2>&1
  case "$?" in
  "17")
    echolog "warning" "xCAT post-booting process is not completed yet. Abort. Please try later."
    exit 255
    ;;
  esac
  ;;
esac

update_VPD()
{
    if [ -f /usr/sbin/vpdupdate ]; then
        echolog "info" "updating VPD database"
        vpdupdate
        #logger -t xCAT -p local4.info "xcatdsklspost: updating VPD database"
    else
        echolog "warning" "/usr/sbin/vpdupdate is not available, please check and do VPD update later"
    fi
}

if [ $NODE_DEPLOYMENT -eq 1 ] || [ "$MODE" = "4" ] || [ "$MODE" = "6" ]; then
    # Run updatevpd only when necessary
    if [ -f /usr/sbin/lsvpd ]; then
        /usr/sbin/lsvpd | grep -i -E 'cpu|processor' 2>&1 1>/dev/null
        if [ "$?" = "1" ]; then
            update_VPD
        fi
    fi
fi

if [ $NODE_DEPLOYMENT -ne 1 ] && [ $MODE -ne 4 ] ; then
  echolog "info" "=============updatenode starting===================="
fi
# set the default path for the xcatpost directory
xcatpost="/xcatpost"
# Check for debug mode and you have nodename available you can change the path for debug

echolog "debug" "Running $0 $*"


if [ -n "$XCATDEBUG" ]; then
  if [ -n "$NODE" ]; then
     xcatpost="/xcatpost.$NODE"
  fi
fi
#echo "xcatpost = $xcatpost"

useflowcontrol=0
if [ "$USEFLOWCONTROL" = "1" ]; then
  useflowcontrol=1
fi
# from install kcmdline
if [ "$FC" = "1" ] || [ "$FC" = "yes" ] || [ "$FC" = "YES" ]; then
  useflowcontrol=1
fi


# If on AIX node
if [ ! `uname` = Linux ]; then
   #Get a new copy of xcataixpost on the node
   mkdir -p  /$xcatpost;
   mkdir -p  /xcatmnt;
   if [ "$NFSV4" = "yes" ]; then
         mount -o vers=4 $P_SIP:$INSTALLDIR/postscripts /xcatmnt
   else
         mount $P_SIP:$INSTALLDIR/postscripts /xcatmnt
   fi
   cp /xcatmnt/xcataixpost /$xcatpost
   umount /xcatmnt
   rmdir /xcatmnt
  logger -t xcat -p local4.err "Running xcataixpost $*"
  # note not supporting -F or -V on AIX
  echo "/$xcatpost/xcataixpost $1 $2 $3 '"$4"' $5 $6 $7 $8 $9 ${10} ${11}"
  exec /$xcatpost/xcataixpost $1 $2 $3 "$4" $5 $6 $7 $8 $9 ${10} ${11}
  exit
fi

#SLI=$(awk 'BEGIN{srand(); printf("%d\n",rand()*10)}')
#sleep $SLI

if [ ! -d /$xcatpost ]; then
    mkdir -p /$xcatpost;
fi

if [ ! -d /tmp/postage ]; then
    mkdir -p /tmp/postage
fi
rm -R -f /tmp/postage/*

#here we get all the postscripts.  Please do not change this behaviour because some scripts depend on others
cd /tmp/postage

echolog "info" "trying to download postscripts..."
if [ "$MODE" = "4" ]; then # for statelite mode
    # We have written the xCATSERVER info into the kernel command line!!
    for i in `cat /proc/cmdline`; do
        KEY=`echo $i | awk -F= '{print $1}'`
        if [ "$KEY" =  "XCAT" ]; then
            TMP=`echo $i | awk -F= '{print $2}'`
            XCATSERVER=`echo $TMP | cut -d: -f1`
            grep 'XCATSERVER' /opt/xcat/xcatinfo > /dev/null  2>&1
            if [ $? -eq 0 ]; then
                sed -i "s/XCATSERVER=.*/XCATSERVER=$XCATSERVER/" /opt/xcat/xcatinfo
            else
                echo "XCATSERVER=$XCATSERVER" >> /opt/xcat/xcatinfo
            fi
        elif [ "$KEY" =  "XCATHTTPPORT" ]; then
            HTTPPORT=`echo $i | awk -F= '{print $2}'`
            grep 'HTTPPORT' /opt/xcat/xcatinfo > /dev/null  2>&1
            if [ $? -eq 0 ]; then
                sed -i "s/HTTPPORT=.*/HTTPPORT=$HTTPPORT/" /opt/xcat/xcatinfo
            else
                echo "HTTPPORT=$HTTPPORT" >> /opt/xcat/xcatinfo
            fi
        fi
    done

    if [ -f /opt/xcat/xcatinfo ]; then
        SIP=`grep 'XCATSERVER' /opt/xcat/xcatinfo |cut -d= -f2 | sed "s/'//g"`
        HTTPPORT=`grep 'HTTPPORT' /opt/xcat/xcatinfo |cut -d= -f2 | sed "s/'//g"`
        if [ -n "$SIP" ]; then
            download_postscripts $SIP:${HTTPPORT}
            if [ $? -eq 0 ]; then
                downloaded=1
            fi
        fi
    else
        #echo "xCAT management server IP can't be determined.";
        #echo "exiting...";
        #logger -t xCAT -p local4.err "xcatdsklspost:xCAT management server IP can't be determined.\nexiting...";
        echolog "err" "xCAT management server IP can't be determined.\nexiting..."
        exit;
    fi


else # for common mode  MODE=1,2,3,5 (updatenode,moncfg,node deployment)
    # non-Statelite MODE

    # If we have written the NODE info into the kernel command line,
    # put in in xcatinfo
    if [ ! -f /opt/xcat/xcatinfo ]; then
        mkdir -p /opt/xcat
        touch /opt/xcat/xcatinfo
    fi
    for i in `cat /proc/cmdline`; do
        KEY=`echo $i | awk -F= '{print $1}'`
        if [ "$KEY" =  "NODE" ]; then
            NODE=`echo $i | awk -F= '{print $2}'`
            break
        fi
    done
    if [ -z "$NODE" ]; then
         NODE=`hostname -s`
    fi

    downloaded=0;  #  have not downloaded the postscripts
    # try the -m/-M input (P_SIP) if it is specified,
    # -m/-M is passed in the updatenode command
    # and is the address of the xcatmaster for this node.  Using -M just means
    # also update the XCATSERVER in the /etc/xcat/xcatinfo file with this
    # address
    if [ -n "$P_SIP" ]; then   # passed in with updatenode on -M/-m
        #SIP="${P_SIP}:${HTTPPORT}"
        SIP=${P_SIP}
        download_postscripts ${P_SIP}:${HTTPPORT}
        if [ $? -eq 0 ]; then
            downloaded=1
        fi
    fi
    # if the download failed then, if not updatenode
    # open the xcatinfo file to look for an XCATSERVER address to try
    # if the address if not the same as the one on the -m/M flag then
    # try it
    if [ $downloaded -eq 0 ]; then

        # if this is an updatenode call, then stop trying and
        # return an error
        if [ "$MODE" = "1" ] || [ "$MODE" = "2" ] || [ "$MODE" = "5" ]; then # updatenode
            hn=`hostname`
            #echo "Cannot download the postscripts from $SIP  for $hn check /tmp/wget.log on the node."
            #logger -t xCAT -p local4.err "xcatdsklspost:Cannot download the postscripts from the xCAT server $SIP for node $hn check /tmp/wget.log on the node."
            echolog "err" "cannot download the postscripts from the xCAT server $SIP for node $hn check /tmp/wget.log on the node."
            exit
        fi

        # if not updatenode, then look in xcatinfo for the xcatmaster
        if [ -f /opt/xcat/xcatinfo ]; then
            SIP=`grep 'XCATSERVER' /opt/xcat/xcatinfo |cut -d= -f2 | sed "s/'//g"`
            HTTPPORT=`grep 'HTTPPORT' /opt/xcat/xcatinfo |cut -d= -f2 | sed "s/'//g"`
            [ -z "$HTTPPORT" ] && HTTPPORT="80"
            if [ -n "$SIP" ]; then
                download_postscripts ${SIP}:${HTTPPORT}
                if [ $? -eq 0 ]; then
                  downloaded=1
                fi
            fi
        fi
    fi

    # download postscripts has not worked yet
    if [ $downloaded -eq 0 ]; then

         # for the non-updatenode calls try the host in the XCAT kernel param.
         for i in `cat /proc/cmdline`; do
             KEY=`echo $i | awk -F= '{print $1}'`
             if [ "$KEY" =  "XCAT" ]; then
                 TMP=`echo $i | awk -F= '{print $2}'`
                 SIP=`echo $TMP | cut -d: -f1`

             elif [ "$KEY" = "XCATHTTPPORT" ];then
                 HTTPPORT=$(echo $i | awk -F= '{print $2}')
                 [ -z "$HTTPPORT" ] && HTTPPORT="80"
             fi
         done

         if [ -n "$SIP" ]; then
             download_postscripts "${SIP}:${HTTPPORT}"
             if [ $? -eq 0 ]; then
                 downloaded=1
             fi
         fi
    fi

    # download poscripts has not worked yet
    #try the dhcp server, this is used for initial boot for the node.
    if [ $downloaded -eq 0 ]; then
        #setup $OSVER ,for SLES11
        if [ -e '/etc/SuSE-release' ]; then
            OSVER=`grep -h VERSION /etc/SuSE-release |awk '{print $3}'`
        fi
        SIPS=`grep -h dhcp-server-identifier /var/lib/dhclient/dhclient*eth*.leases 2> /dev/null|awk '{print $3}'|sed -e 's/;//'`
        if [ -z "$SIPS" ]; then
            SIPS=`grep -h dhcp-server-identifier /var/lib/dhclient/dhclient*hf*.leases 2> /dev/null|awk '{print $3}'|sed -e 's/;//'`
            if [ -z "$SIPS" ]; then
                SIPS=`grep -h DHCPSID /var/lib/dhcpcd/*.info 2> /dev/null|awk -F= '{print $2}'|sed -e s/\'//g`
            fi
        fi
        SIP=`echo $SIPS|awk '{printf $NF}' | tail -n 1` #Pick one for wget
        if [ -n "$SIP" ]; then
            download_postscripts $SIP
            if [ $? -eq 0 ]; then
                downloaded=1
            fi
        elif [ -x "/sbin/dhcpcd" ]; then
            # New dhcpcd doesn't creates *.info files.
            for lease in $(ls "/var/lib/dhcpcd/"); do
                iface="$(echo "$lease" | sed -n -e 's/^dhcpcd-\(.*\)\.lease$/\1/p')"
                if [ -n "$iface" ]; then
                    SIP="$(dhcpcd -q -T "$iface" | sed -n -e '/new_dhcp_server_identifier/ s/.*=//p')"
                    if [ -n "$SIP" ]; then
                        download_postscripts $SIP
                        if [ $? -eq 0 ]; then
                            downloaded=1
                            break
                        fi
                    fi
                fi
            done
        fi
    fi

    #no hope to download postscripts, now let's get out of here.
    if [ $downloaded -eq 0 ]; then
        hn=`hostname`
        #echo "Cannot download the postscripts from the xCAT server for node $hn"
        #logger -t xCAT -p local4.err "xcatdsklspost:Cannot download the postscripts from the xCAT server for node $hn"
        echolog "err" "failed to download the postscripts from the xCAT server for node $hn"
        exit 1
    else
        echolog "info" "postscripts downloaded successfully"
    fi

fi # finish the postscripts download

# remove the current mypostscript file
rm -rf /$xcatpost/mypostscript

# if NODE is exported ( updatenode call or from kernel parameter)
# use it as the nodename to get the mypostscript file.
if [ -n "$NODE" ]; then
  node_short=$NODE
else
  #get node name and download the mypostscript.$node file
  #try to get the node ip address that connects to the server.
  #then resolve the name of the ip
  real_SIP=`getent hosts $SIP |awk {'print $1'}`
  if [ $? -ne 0 ]; then
    real_SIP=$SIP
  fi

  NIP=`ip route get $real_SIP | head -n 1 | sed 's/^.*src//g' | awk {'print $1'}`
  if [ $? -eq 0 ] && [ -n "$NIP" ]; then
    #resolve the name of the node from ip address
    result=`getent hosts $NIP`
    if [ $? -eq 0 ]; then
      node1=`echo $result | awk {'print $2'}`
      node2=`echo $result | awk {'print $3'}`
      if [ ${#node1} -gt ${#node2} ]; then
        node=$node1
        node_short=$node2
      else
        node=$node2
        node_short=$node1
      fi
      if [ -z "$node_short" ]; then
        node_short=`echo $node |awk -F. {'print $1'}`
      fi
    else
      if [ -z "$node" ]; then
        node=`hostname`
        node_short=`hostname -s`
      fi
    fi
  else
    node=`hostname`
    node_short=`hostname -s`
  fi
fi

echolog "info" "trying to get mypostscript from $SIP..."
max_retries=2
# try short hostname first
if [ -n "$node_short" ]; then
    download_mypostscript "${SIP}:${HTTPPORT}" $node_short $max_retries $TFTPDIR
    if [ $? -ne 0 ]; then
        # try long hostname
        if [ "$node" != "$node_short" ]; then
          download_mypostscript "${SIP}:${HTTPPORT}" $node $postfix $max_retries $TFTPDIR
        fi
    fi
fi

# on reboot and shutdown, make sure /ro and /rw are not stuck mounted
if grep 'rw /rw tmpfs ' /proc/mounts  >/dev/null 2>&1; then
    touch /var/lock/subsys/xcatmounts
    echo '#!/bin/bash' > /etc/rc6.d/K10xcatmounts
    echo umount -l /ro >> /etc/rc6.d/K10xcatmounts
    echo umount -l /rw >> /etc/rc6.d/K10xcatmounts
    chmod 755 /etc/rc6.d/K10xcatmounts
    ln -sf /etc/rc6.d/K10xcatmounts /etc/rc0.d/K10xcatmounts
fi

# To support the postscripts in the subdirectories under /install/postscripts
#chmod +x /$xcatpost/*;
chmod -R +x `find $xcatpost/ -maxdepth 1 -print | grep -E -v "^($xcatpost/|$xcatpost/_xcat|$xcatpost/_ssh|$xcatpost/ca|$xcatpost/hostkeys)$"`

cd /$xcatpost;
PATH=/$xcatpost:$PATH
export PATH

if [ -x /usr/bin/openssl ]; then
     XCATSERVER="$SIP:3001"
     export XCATSERVER
     USEOPENSSLFORXCAT=1 #Though this is the only method going forward, flag to allow backward compatibility with 2.2 generated netboot images
     export USEOPENSSLFORXCAT
fi

# if download of postscript failed,
# probably  the /tftpboot/mypostcript/mypostscript.<nodename> does not exist.
# We need to call getpostscript.awk .

if [ ! -x /$xcatpost/mypostscript ]; then
  echolog "debug" "no pre-generated mypostscript.<nodename>, trying to get it with getpostscript.awk..."
  if [ $useflowcontrol = "1" ]; then
    # first contact daemon  xcatflowrequest <server> 3001
    #logger -t xCAT -p local4.info "xcatdsklspost:sending xcatflowrequest $SIP 3001"
    echolog "debug" "sending xcatflowrequest $SIP 3001"
    /$xcatpost/xcatflowrequest $SIP 3001
    rc=$?
    #logger -t xCAT -p local4.info "xcatdsklspost:xcatflowrequest return=$rc"
    echolog "debug" "xcatflowrequest return=$rc"
    if [ $rc -ne 0 ]; then
      #logger -t xCAT -p local4.info "xcatdsklspost: error from xcatflowrequest, will not use flow control"
      echolog "debug" "error from xcatflowrequest, will not use flow control"
      useflowcontrol=0
    fi
  fi
  /$xcatpost/getpostscript.awk | egrep  '<data>' | sed  -e 's/<[^>]*>//g'|egrep -v '^ *$'|sed -e 's/^ *//' | sed -e 's/&lt;/</g' -e 's/&gt;/>/g' -e 's/&amp;/\&/g' -e 's/&quot;/"/g' -e "s/&apos;/'/g" >  /$xcatpost/mypostscript;


 MYCONT=`grep MASTER /$xcatpost/mypostscript`
 MAX_RETRIES=10
 RETRY=0
 while [ -z "$MYCONT" ]; do
    # not using flow control , need to sleep
    if [ $useflowcontrol = "0" ]; then
        let SLI=$RANDOM%10
        let SLI=SLI+10
        sleep $SLI
    fi

    RETRY=$(($RETRY+1))
    if [ $RETRY -eq $MAX_RETRIES ]
    then
        break
    fi

    if [ $useflowcontrol = "1" ]; then
      # contact daemon  xcatflowrequest <server> 3001
      #logger -t xCAT -p local4.info "xcatdsklspost: sending xcatflowrequest $SIP 3001"
      echolog "debug" "sending xcatflowrequest $SIP 3001"
      /$xcatpost/xcatflowrequest $SIP 3001
      rc=$?
      #logger -t xCAT -p local4.info "xcatdsklspost:xcatflowrequest return=$rc"
      echolog "debug" "xcatflowrequest return=$rc"
      if [ $rc -ne 0 ]; then
        #logger -t xCAT -p local4.info "xcatdsklspost: error from xcatflowrequest, will not use flow control"
        echolog "debug" "error from xcatflowrequest, will not use flow control"
        useflowcontrol=0
      fi
    fi
    /$xcatpost/getpostscript.awk | egrep  '<data>' | sed  -e 's/<[^>]*>//g'|egrep -v '^ *$'|sed -e 's/^ *//' | sed -e 's/&lt;/</g' -e 's/&gt;/>/g' -e 's/&amp;/\&/g' -e 's/&quot;/"/g' -e "s/&apos;/'/g" >  /$xcatpost/mypostscript;
    MYCONT=`grep MASTER /$xcatpost/mypostscript`
    if [ ! -z "$MYCONT" ]; then
        break;
    fi
 done
fi

#save the MASTER into the xcatinfo file for node deployment case,
#for updatenode case, only save it when -M is specified
if [ $NODE_DEPLOYMENT -eq 1 ] || [ "$MODE" = "4" ]; then
    new_ms=`grep '^MASTER' /$xcatpost/mypostscript |head -n 1 |cut -d= -f2`
fi
if [ -n "$new_ms" ]; then
    if [ ! -f /opt/xcat/xcatinfo ]; then
      mkdir -p /opt/xcat
      touch /opt/xcat/xcatinfo
    fi
    grep 'XCATSERVER' /opt/xcat/xcatinfo > /dev/null  2>&1
    if [ $? -eq 0 ]; then
      sed -i "s/XCATSERVER=.*/XCATSERVER=$new_ms/" /opt/xcat/xcatinfo
    else
      echo "XCATSERVER=$new_ms" >> /opt/xcat/xcatinfo
    fi

    grep 'HTTPPORT' /opt/xcat/xcatinfo > /dev/null  2>&1
    if [ $? -eq 0 ]; then
      sed -i "s/HTTPPORT=.*/HTTPPORT=$HTTPPORT/" /opt/xcat/xcatinfo
    else
      echo "HTTPPORT=$HTTPPORT" >> /opt/xcat/xcatinfo
    fi
fi

#save the USEFLOWCONTROL into the xcatinfo file
#for updatenode case, passwd in with the -f flag
if [ $NODE_DEPLOYMENT -eq 1 ] || [ "$MODE" = "4" ]; then
    useflowcontrol=`grep '^USEFLOWCONTROL' /$xcatpost/mypostscript |cut -d= -f2 | tr -d \'\" | tr A-Z a-z`
fi
if [ ! -f /opt/xcat/xcatinfo ]; then
  mkdir -p /opt/xcat
  touch /opt/xcat/xcatinfo
fi
if [ -n "$useflowcontrol" ]; then
    # lets just put YES or NO in xcatinfo
    if [[ "$useflowcontrol" =~ ^(1|yes|y)$ ]]; then
       new_fc="YES"
    else
       new_fc="NO"
    fi
# no setting means do not use flowcontrol
else
    new_fc="NO"
fi
grep 'USEFLOWCONTROL' /opt/xcat/xcatinfo > /dev/null  2>&1
if [ $? -eq 0 ]; then
    sed -i "s/USEFLOWCONTROL=.*/USEFLOWCONTROL=$new_fc/" /opt/xcat/xcatinfo
else
    echo "USEFLOWCONTROL=$new_fc" >> /opt/xcat/xcatinfo
fi

# Add Node name to /opt/xcat/xcatinfo
if [ -z "$NODE" ]; then
    NODE=`hostname -s`
fi
grep 'NODE' /opt/xcat/xcatinfo > /dev/null  2>&1
if [ $? -eq 0 ]; then
    sed -i "s/NODE=.*/NODE=$NODE/" /opt/xcat/xcatinfo
else
    echo "NODE=$NODE" >> /opt/xcat/xcatinfo
fi


# Store the SERVICEGROUP into the xcatinfo file for node deployment, and also for updatenode -s
if [ $NODE_DEPLOYMENT -eq 1 ] || [ "$MODE" = "1" ]; then
    sn_group=`grep '^SERVICEGROUP' /$xcatpost/mypostscript |cut -d= -f2 | tr -d \'\"`
    if [ "x" != "x$sn_group" ]; then
      # Change or add SERVICEGROUP line if service node pool defined.
      grep 'SERVICEGROUP=' $XCATINFOFILE > /dev/null 2>&1
      if [ $? -eq 0 ]; then
        sed -i "s/SERVICEGROUP=.*/SERVICEGROUP=$sn_group/" $XCATINFOFILE
      else
        echo "SERVICEGROUP=$sn_group" >> $XCATINFOFILE
      fi
    else
      # Remove SERVICEGROUP line if no service node pool defined.
      sed -i "/SERVICEGROUP=.*/d" $XCATINFOFILE
    fi
fi

# when called by the updatenode command  MODE=1,2
# the nodename is passed in by xdsh in the NODE environment variable by xdsh.

#modify the UPDATENODE flag to 1
# put NODE in /opt/xcat/xcatinfo
if [ "$MODE" = "1" ] || [ "$MODE" = "2" ]; then
  TMP=`sed -e 's/UPDATENODE=0/UPDATENODE=1/g' /$xcatpost/mypostscript`;
  echo "$TMP" > /$xcatpost/mypostscript;
  if [ ! -f /opt/xcat/xcatinfo ]; then
    mkdir -p /opt/xcat
    touch /opt/xcat/xcatinfo
  fi
  if [ -z "$NODE" ]; then
    NODE=`hostname -s`
  fi
  grep 'NODE' /opt/xcat/xcatinfo > /dev/null  2>&1
  if [ $? -eq 0 ]; then
    sed -i "s/NODE=.*/NODE=$NODE/" /opt/xcat/xcatinfo
  else
    echo "NODE=$NODE" >> /opt/xcat/xcatinfo
  fi
#echo "xcatdsklspost:my nodename in the database is $NODE"
fi
if [ "$MODE" = "5" ]; then
  TMP=`sed -e 's/UPDATENODE=0/UPDATENODE=1\nUPDATESECURITY=1\nexport UPDATESECURITY/g' /$xcatpost/mypostscript`;
  echo "$TMP" > /$xcatpost/mypostscript;
fi

#when a diskfull reboot mode
if [ "$MODE" = "6" ]; then
  # remove the post scripts so that they are not run on reboot
  TMP=`sed "/# postscripts-start-here/,/# postscripts-end-here/ d" /$xcatpost/mypostscript`
  echo "$TMP" > /$xcatpost/mypostscript
  # get the RUNBOOTSCRIPTS site variable
  if [ -f /$xcatpost/mypostscript ]; then
    RUNBOOTSCRIPTS=`grep 'RUNBOOTSCRIPTS=' /$xcatpost/mypostscript |cut -d= -f2 | tr -d \'\" | tr A-Z a-z `
  fi

  # if admin did not requested running of post boot scripts - then remove PBS
  if [[ !  "$RUNBOOTSCRIPTS" =~ ^(1|yes|y)$ ]]; then
  #remove all the postscripts
  TMP=`sed "/# postbootscripts-start-here/,/# postbootscripts-end-here/ d" /$xcatpost/mypostscript`
  echo "$TMP" > /$xcatpost/mypostscript

  #TMP=`sed "/postbootscripts-start-here/,/postbootscripts-end-here/ d" /$xcatpost/mypostscript.post`
  #echo "$TMP" > /$xcatpost/mypostscript.post
  fi
fi

# postscript name is specified with the updatenode
#cp /$xcatpost/mypostscript /$xcatpost/mypostscript.backup
# if the list has a postscript named *start-here* then we must rebuild the
# mypostscript file with only the matching *start-here stanza.


if ( pmatch $POSTSCRIPTS  "*start-here*" ); then
  if ( pmatch $POSTSCRIPTS  "*osimage-postbootscripts-start-here" ); then
  # remove all sections but the osimage-postbootscripts section
    TMP=`sed "/# postscripts-start-here/,/# postscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# defaults-postbootscripts-start-here/,/# defaults-postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# node-postbootscripts-start-here/,/# node-postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
  fi
  if ( pmatch $POSTSCRIPTS  "*postscripts-start-here" ); then
    #remove all the postbootscripts
    TMP=`sed "/# postbootscripts-start-here/,/# postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
  fi
  if ( pmatch $POSTSCRIPTS  "*postbootscripts-start-here" ); then
    #remove all the postscripts
    TMP=`sed "/# postscripts-start-here/,/# postscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript

  fi
  if ( pmatch $POSTSCRIPTS  "*defaults-postscripts-start-here" ); then
  # remove all sections but the defaults-postscripts section
    TMP=`sed "/# osimage-postscripts-start-here/,/# osimage-postscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# node-postscripts-start-here/,/# node-postscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# postbootscripts-start-here/,/# postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
  fi

  if ( pmatch $POSTSCRIPTS  "*node-postscripts-start-here" ); then
  # remove all sections but the node-postscripts section
    TMP=`sed "/# osimage-postscripts-start-here/,/# osimage-postscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# defaults-postscripts-start-here/,/# defaults-postscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# postbootscripts-start-here/,/# postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
  fi

  if ( pmatch $POSTSCRIPTS  "*defaults-postbootscripts-start-here" ); then
  # remove all sections but the defaults-postbootscripts section
    TMP=`sed "/# osimage-postbootscripts-start-here/,/# osimage-postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# node-postbootscripts-start-here/,/# node-postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# postscripts-start-here/,/# postscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
  fi


  if ( pmatch $POSTSCRIPTS  "*node-postbootscripts-start-here" ); then
  # remove all sections but the node-postbootscripts section
    TMP=`sed "/# osimage-postbootscripts-start-here/,/# osimage-postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# defaults-postbootscripts-start-here/,/# defaults-postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    TMP=`sed "/# postscripts-start-here/,/# postscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
  fi


# check to see if input postscript list is not empty. If there is a list
# remove the built postscripts and only add the ones for the list.
else
   if [ -n "$POSTSCRIPTS" ]; then
    #remove all the postbootscripts, and replace with list provided
    TMP=`sed "/# postbootscripts-start-here/,/# postbootscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    #remove all the postscripts
    TMP=`sed "/# postscripts-start-here/,/# postscripts-end-here/ d" /$xcatpost/mypostscript`
    echo "$TMP" > /$xcatpost/mypostscript
    echo "# postscripts-start-here" >> /$xcatpost/mypostscript
    #add requested postscripts in
    echo "$POSTSCRIPTS" | tr "," "\n" >> /$xcatpost/mypostscript
    echo "# postscripts-end-here" >> /$xcatpost/mypostscript

  fi
fi

#ADDSITEYUM is set by post.rh and post.rh.iscsi for full installtion
#if [[ "$ADDSITEYUM" = "1" ]]; then
#  TMP=`sed "/postscripts-start-here/ a addsiteyum" /$xcatpost/mypostscript`
#  echo "$TMP" > /$xcatpost/mypostscript
#fi

#MYCONT=`cat /$xcatpost/mypostscript`
#echo "$MYCONT"

# use the run_ps subroutine to run the postscripts
if [ $NODE_DEPLOYMENT -eq 1 ] || [ "$MODE" = "4" ] || [ "$MODE" = "6" ]; then
    TMP=`sed "/# postscripts-start-here/,/# postscripts-end-here/ s/\(.*\)/run_ps postbootscript \1/;s/run_ps postbootscript\s*#/#/;s/run_ps postbootscript\s*$//" /$xcatpost/mypostscript`
else
    TMP=`sed "/# postscripts-start-here/,/# postscripts-end-here/ s/\(.*\)/run_ps postscript \1/;s/run_ps postscript\s*#/#/;s/run_ps postscript\s*$//" /$xcatpost/mypostscript`
fi
echo "#!/bin/bash
. /xcatpost/xcatlib.sh

# global value to store the running status of the postbootscripts,the value is non-zero if one postbootscript failed
return_value=0
# subroutine used to run postscripts
# \$1 argument is the script type
# rest argument is the script name and arguments
run_ps () {
 local ret_local=0
 mkdir -p "\"/var/log/xcat\""
 local logfile=\"/var/log/xcat/xcat.log\"
 local scriptype=\$1
 shift;

 if [ -z \"\$scriptype\" ]; then
  scriptype=\"postscript\"
 fi
 if [ \$UPDATENODE -eq 0 ]; then
     log_label=\"xcat.deployment.\"\$scriptype
 else
     log_label=\"xcat.updatenode.\"\$scriptype
 fi
 export LOGLABEL=\$log_label
 if [ -f \$1 ]; then
  echo \"\$scriptype start..: \$1\"
  msgutil_r \"\$MASTER_IP\" \"info\" "\"\$scriptype start..: \$1\"" \"\$logfile\" \"\$log_label\"
  if [ \"\$XCATDEBUGMODE\" = \"1\" ] || [ \"\$XCATDEBUGMODE\" = \"2\" ]; then
     local compt=\$(file \$1)
     local reg=\"shell script\"
     if [[ \"\$compt\" =~ \$reg ]]; then
        bash -x ./\$@ 2>&1 | tee -a \$logfile | tee >(logger -t \$log_label -p debug)
        ret_local=\${PIPESTATUS[0]}
     else
        ./\$@ 2>&1 | tee -a \$logfile | tee >(logger -t \$log_label -p debug)
        ret_local=\${PIPESTATUS[0]}
     fi
  else
     ./\$@ 2>&1 | tee -a \$logfile
     ret_local=\${PIPESTATUS[0]}
  fi

  if [ \"\$ret_local\" -ne \"0\" ]; then
     return_value=\$ret_local
  fi
  echo \"\$scriptype end....: \$1 exited with code \$ret_local\"
  msgutil_r \"\$MASTER_IP\" \"info\" "\"\$scriptype end...:\$1 return with \$ret_local\"" \"\$logfile\" \"\$log_label\"
 else
  echo \"\`date\` \$scriptype \$1 does NOT exist.\"
  msgutil_r \"\$MASTER_IP\" \"error\" "\"\$scriptype \$1 does NOT exist.\"" \"\$logfile\" \"\$log_label\"
  return_value=-1
 fi

 return 0
}
# subroutine end

" > /$xcatpost/mypostscript
echo "$TMP" >> /$xcatpost/mypostscript
if [ "$MODE" = "1" ] || [ "$MODE" = "2" ]  || [ "$MODE" = "3" ] || [ "$MODE" = "5" ]; then
    TMP=`sed "/# postbootscripts-start-here/,/# postbootscripts-end-here/ s/\(.*\)/run_ps postscript \1/;s/run_ps postscript\s*#/#/;s/run_ps postscript\s*$//" /$xcatpost/mypostscript`
else
    TMP=`sed "/# postbootscripts-start-here/,/# postbootscripts-end-here/ s/\(.*\)/run_ps postbootscript \1/;s/run_ps postbootscript\s*#/#/;s/run_ps postbootscript\s*$//" /$xcatpost/mypostscript`
fi
echo "$TMP" > /$xcatpost/mypostscript

if [ $NODE_DEPLOYMENT -eq 1 ] || [ "$MODE" = "4" ] || [ "$MODE" = "6" ]; then
  #notify the server that we are done with netbooting
  CNS=`grep NODESTATUS= /$xcatpost/mypostscript |awk -F = '{print $2}' | tr -d \'\" | tr A-Z a-z`
  if [ -z "$CNS" ] || [[ "$CNS" =~ ^(1|yes|y)$  ]]; then
# TMP=`sed "/postscripts-start-here/ i\updateflag.awk \\$MASTER 3002 \\"installstatus configuring\\"" /$xcatpost/mypostscript`
#       echo "$TMP"> /$xcatpost/mypostscript
    if [ "$MODE" = "6" ]; then
        echo "
if [ \"\$return_value\" -eq \"0\" ]; then
    msgutil_r \$MASTER_IP \"debug\" \"node booted successfully, reporting status...\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
    updateflag.awk \$MASTER 3002 \"installstatus booted\"
else
    msgutil_r \$MASTER_IP \"debug\" \"node boot failed, reporting status...\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
    updateflag.awk \$MASTER 3002 \"installstatus failed\"
fi
        " >> /$xcatpost/mypostscript
    else
        echo "
if [ \"\$return_value\" -eq \"0\" ]; then
    msgutil_r \$MASTER_IP \"debug\" \"node booted successfully, reporting status...\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
    updateflag.awk \$MASTER 3002 \"installstatus booted\"
    msgutil_r \$MASTER_IP \"info\" \"provision completed.(\$NODE)\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
else
    msgutil_r \$MASTER_IP \"debug\" \"node boot failed, reporting status...\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
    updateflag.awk \$MASTER 3002 \"installstatus failed\"
    msgutil_r \$MASTER_IP \"error\" \"provision completed with error.(\$NODE)\" \"/var/log/xcat/xcat.log\" \"\$log_label\"
fi
        " >> /$xcatpost/mypostscript
    fi
  fi
fi

DHCP_TMP=`sed 's/\(DHCPINTERFACES=\)\(.*\)$/\1"\2"/' /$xcatpost/mypostscript`
echo "$DHCP_TMP" > /$xcatpost/mypostscript

CLEANUPXCATPOST=`grep CLEANUPXCATPOST= /$xcatpost/mypostscript |awk -F = '{print $2}' | tr -d \'\" | tr A-Z a-z`
if [[ "$CLEANUPXCATPOST" =~ ^(1|yes|y)$ ]]; then
  echo "cd /" >> /$xcatpost/mypostscript
  # /xcatpost might be read-only for statelite nodes
  echo "rm -rf /$xcatpost/*" >> /$xcatpost/mypostscript
fi



if [ "$MODE" = "1" ] || [ "$MODE" = "2" ] || [ "$MODE" = "5" ]; then
  echo "exit \$return_value" >> /$xcatpost/mypostscript
fi

chmod 700 /$xcatpost/mypostscript
if [ -x /$xcatpost/mypostscript ];then
   echolog "debug" "Running /$xcatpost/mypostscript"
   /$xcatpost/mypostscript
   VRET_POST=$?
   echolog "debug" "/$xcatpost/mypostscript return with $VRET_POST"
fi

#tell user it is done when this is called by updatenode command
if [ "$MODE" = "1" ] || [ "$MODE" = "2" ] || [ "$MODE" = "5" ]; then
  echo "returned from postscript"
  echolog "info" "=============updatenode ending===================="
fi

if [ $NODE_DEPLOYMENT -eq 1 ] || [ "$MODE" = "4" ] || [ "$MODE" = "6" ]; then
  echolog "info" "=============deployment ending===================="
fi

exit $VRET_POST
EOF
chmod 755 /opt/xcat/xcatdsklspost

if [ ! -x /opt/xcat/xcatdsklspost ]; then
    msgutil_r "$MASTER_IP" "error" "failed to generate /opt/xcat/xcatdsklspost" "/var/log/xcat/xcat.log" "$log_label"
else
    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
        msgutil_r "$MASTER_IP" "debug" "/opt/xcat/xcatdsklspost generated" "/var/log/xcat/xcat.log" "$log_label"
    fi
fi


#create the preboot script and run here
TMP=`sed "/^#\s*postbootscripts-start-here/,/^#\s*postbootscripts-end-here/ d" /xcatpost/mypostscript`
echo "$TMP" > /xcatpost/mypostscript

echo "
#save bad return code to /opt/xcat/xcatinfo
if [ \"\$return_value\" -ne \"0\" ]; then
    grep 'POSTSCRIPTS_RC' /opt/xcat/xcatinfo > /dev/null 2>&1
    if [ \$? -eq 0 ]; then
        sed -i \"s/POSTSCRIPTS_RC=.*/POSTSCRIPTS_RC=1/\" /opt/xcat/xcatinfo
    else
        echo \"POSTSCRIPTS_RC=1\" >> /opt/xcat/xcatinfo
    fi
fi
" >> /xcatpost/mypostscript

chmod 700 /xcatpost/mypostscript

export ARCH=x86_64
export CONSOLEPORT=0

#for redhat:
#place-holder for the code to save the repo info on compute node,pointing to the "pkgdir" of the osimage
#so that the provisioned node has the repo pointed to the distro path on MN


if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
   msgutil_r "$MASTER_IP" "info" "running mypostscript" "/var/log/xcat/xcat.log" "$log_label"
fi
/xcatpost/mypostscript
if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
   msgutil_r "$MASTER_IP" "info" "mypostscript returned" "/var/log/xcat/xcat.log" "$log_label"
fi


if [[ $OSVER == ubuntu* ]]; then
    if [[ -r /boot/grub/menu.lst ]]; then
        sed -i 's/^serial/#serial/' /boot/grub/menu.lst
        sed -i 's/^terminal/#terminal/' /boot/grub/menu.lst
    elif [[ -r /boot/grub/grub.cfg ]] ; then
        update-grub
    fi

    #print the kernel messages and service start messages with systemd on the console during system bootup
    [ -f /etc/default/grub ] && sed -i -e '/GRUB_CMDLINE_LINUX_DEFAULT=/s/quiet//;s/splash//' -e '/#GRUB_TERMINAL=/s/#//' -e 's/#GRUB_GFXMODE=.*/GRUB_GFXMODE=text/' /etc/default/grub && update-grub

    if echo "$ARCH" | grep -i 'x86_64'; then
        #grab the install-time console configuration from /proc/cmdline inside os installer
        CONSOLECFG=$(awk 'BEGIN{RS="[ \n]" ;ORS=" "} $0 ~ /^console=/{print $0}' /proc/cmdline)
        #if the console configuration is not applied to the grub configuration,apply it
        cat /boot/grub/grub.cfg |grep "$CONSOLECFG" >/dev/null 2>&1 || ([ -f /etc/default/grub ] && sed -i -e "/GRUB_CMDLINE_LINUX_DEFAULT=/s/=\"/=\" $CONSOLECFG /" /etc/default/grub && update-grub)
    fi
    if echo "$ARCH" | grep -i 'ppc64'; then
        if [ -z "$CONSOLEPORT" ] ; then
            export CONSOLEPORT=0
        fi
        CONSOLE="hvc$CONSOLEPORT"
        if [[ -r /etc/default/grub ]] ; then
            sed -i "s/GRUB_CMDLINE_LINUX_DEFAULT=.*/GRUB_CMDLINE_LINUX_DEFAULT=\"console=$CONSOLE\"/" /etc/default/grub
        else
            echo "GRUB_CMDLINE_LINUX_DEFAULT=\"console=$CONSOLE\"" > /etc/default/grub
        fi
        update-grub

cat >/etc/init/$CONSOLE\.conf << 'EOF'
start on stopped rc RUNLEVEL=[2345] and (
         not-container or
         container CONTAINER=lxc or
         container CONTAINER=lxc-libvirt)

stop on runlevel [!2345]
respawn
#exec /sbin/getty -L 115200 hvc0 vt102
script
    for i in `cat /proc/cmdline`; do
        KEY=`echo $i|cut -d= -f 1`
        if [ "$KEY" == "console" -a "$i" != "console=tty0" ]; then
            VALUE=`echo $i | awk -F= '{print $2}'`
            COTTY=`echo $VALUE|awk -F, '{print $1}'`
            COSPEED=`echo $VALUE|awk -F, '{print $2}'|awk -Fn '{print $1}'`

            break
        fi
    done

    exec /sbin/getty -L $COSPEED $COTTY vt102
end script
EOF
    fi
    sed -i '/127.0.1.1/d' /etc/hosts
else
    [ -f /boot/grub/grub.conf  ] && sed -i 's/^serial/#serial/' /boot/grub/grub.conf
    [ -f /boot/grub/grub.conf  ] && sed -i 's/^terminal/#terminal/' /boot/grub/grub.conf
    if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
       msgutil_r "$MASTER_IP" "debug" "/boot/grub/grub.conf updated" "/var/log/xcat/xcat.log" "$log_label"
    fi
fi


msgutil_r "$MASTER_IP" "info" "finished firstboot preparation, sending request to $MASTER:3002 for changing status..." "/var/log/xcat/xcat.log" "$log_label"
#the following command should always be run to prevent infinite installation loops
updateflag.awk $MASTER 3002

cd /

# fix the issue#929@github, the "service network restart" in <sles post scripts>
# makes the 'network' service in start status, then it causes the
# services YaST2-Second-Stage.service and xcatpostinit1 services to be run in parallel.
# But the YaST2-Second-Stage.service calls the Yast2 which conflics with the zypper
# which is called in xcatpostinit1->otherpkgs.
# The correct services start order is 'YaST2-Second-Stage.service'->'network'->'xcatpostinit1' in serial.
# To skip the conflict, the network service should be stoped in the yast first stage. Then base on the service
# dependency, the service start order will be 'YaST2-Second-Stage.service'->'network'->'xcatpostinit1' in serial.
# Then the Yast2 will be stopped before running the zypper in otherpkgs.
if [[ $OSVER =~ sle && $OSVER != sles11* ]]; then
    service network stop
fi

if [ "$XCATDEBUGMODE" = "1" ] || [ "$XCATDEBUGMODE" = "2" ]; then
    set +x
fi
} >>/var/log/xcat/xcat.log 2>&1

]]>

          </source>
        </script>
      </post-scripts>

    </scripts>
  </configure>
</profile>
